<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Lesson-1</title>
    </head>
    <body>
    <h2>Основи популярної бібліотеки</h2> 
    <p>React — це JavaScript-бібліотека для створення інтерфейсів користувача.
        Відвідайте нашу головну сторінку або вступ, аби скласти перше враження про
        React. - https://uk.reactjs.org/docs/getting-started.html
        Для навчання та маленьких/середніх проектів рекомендується використовувати
        утиліту від авторів React.
        Абстрагує всю конфігурацію, дозволяючи зосередитись на написанні коду
        Включає необхідні інструменти: Webpack, Babel, ESLint тощо.
        Розширюється додатковими пакетами із екосистеми React
        Має функцію вилучення, яка видаляє абстракцію та відкриває конфігурацію для створення збірки:</p>
        <p>npx create-react-app *ім*я_папки_проекту</p>
        <p>React — це декларативна, ефективна і гнучка JavaScript-бібліотека, призначена
            для створення інтерфейсів користувача. Вона дозволяє компонувати складні
            інтерфейси з невеликих окремих частин коду — “компонентів”. <br>
            Найменший приклад React виглядає наступним чином: <br>
            ReactDOM.render(<teg>< h1 ></h1></teg>, world!<teg> < /h1 ></teg>, <br>
            document.getElementById('root')); <br>
            На сторінці з’явиться заголовок “Hello, world!” <br>
            React-елементи – це найменші будівельні блоки React, елементи Virtual DOM.
            Елементи – це звичайні JS-об'єкти, тому створювати їх дуже швидко.
            Функція React.createElement() це найголовніший метод, що надається React API.
            Подібно до document.createElement() для DOM, React.createElement() це функція
            для створення React-елементів. Повертає об'єкт елемент Virtual DOM.
            React.createElement(type, [props], [...children])
        </p>
        <p>type - ім'я вбудованого React-елемента який у Virtual DOM відповідає
            майбутньому HTML-тегу
        </p>
        <p>props - об'єкт містить HTML-атрибути та кастомні властивості. Можливо, null або
            порожній об'єкт, якщо передавати нічого не потрібно.
        </p>
        <p>children - довільна кількість аргументів після другого - це діти створюваного
            елемента. Так створюється дерево елементів
        </p>
        <p>Компоненти - основні будівельні блоки React-програм, за допомогою яких
            інтерфейс ділиться розділити на незалежні частини.
        </p>
        <p>Розробник створює невеликі компоненти, які можна поєднувати, щоб сформувати
            більші або використовувати їх як самостійні елементи інтерфейсу. Найголовніше в
            цій концепції те, що і великі, і маленькі компоненти можна використати повторно і
            в поточному, і в новому проекті.
        </p>
        <p>Елемент описує те, що ви хочете бачити на екрані:</p>
        <p>const element = <teg>< h1 ></></teg> Привіт, світе< /h1 >;
            На відміну від DOM-елементів, елементи React — звичайні об’єкти, легкі для
            створення. React DOM бере на себе оновлення DOM для його відповідності
            React-елементам.
        </p>
        <h2>Оновлення відображеного елемента</h2>
        <p>React-елементи є незмінними. Як тільки елемент створений, ви не можете
            змінювати його дочірні елементи чи атрибути. Елемент схожий на кадр із фільму:
            він відображає інтерфейс користувача в певний момент часу.
            З нашими поточними знаннями, єдиний спосіб оновити інтерфейс користувача
            — створити новий елемент і передати його в ReactDOM.render().
            Розглянемо наступний приклад годинника:
        </p>
        <p>function tick() {const element = (< div > <br>
            < h1 >Hello, world!< / > <br>
            < h2 >Зараз {new Date().toLocaleTimeString()}.</> <br>
            < / >); <br>
            ReactDOM.render(element, document.getElementById('root'));}setInterval(tick, 1000);
            Він щосекунди викликає ReactDOM.render() у функції зворотнього виклику
            setInterval(). <br>
            Примітка:
            На практиці, більшість React-додатків викликає ReactDOM.render() лише раз. У
            наступних розділах ми дізнаємось, як такий код інкапсулюється в компоненти зі
            станом.
        </p>
        <h2>Компоненти-функції</h2>
        <p>У найпростішій формі компонент це JavaScript-функція з дуже простим
            контрактом: функція отримує об'єкт властивостей, який називається props і
            повертає дерево React-елементів.
            Ім'я компонента обов'язково має починатися з великої літери. Назви компонентів
            із маленької літери зарезервовані для HTML-елементів. Якщо ви спробуєте
            назвати компонент card, а не Card, при рендері, React проігнорує його та
            відрендерує тег < card > < / >.
        </p>
        <h2>Властивості компонента (props)</h2>
        <p>Властивості (пропси) є однією з основних концепцій React. Компоненти
            приймають довільні властивості і повертають React-елементи, що описують, що
            має відрендеритися в DOM
        </p>
        <p>Пропси використовуються передачі даних від батька до дитини.
            Пропси передаються лише по дереву від батьківського компонента.
            При зміні пропсів React ререндерить компонент і, можливо, оновлює DOM.
            Пропси доступні лише для читання, змінити їх у дитині не можна.
            Пропс може бути текст кнопки, картинка, url, будь-які дані для компонента.
            Пропси можуть бути рядками або результатом JS-виразу. Якщо передано лише
            ім'я пропсу - це буль, за замовчанням true.
        </p>
        <h2>Властивість props.children</h2>
        <p>Концепція дочірніх елементів дозволяє просто робити композицію компонентів.
            У вигляді дітей можна передавати компоненти як вбудовані так і кастомні. Це
            дуже зручно під час роботи зі складними складовими компонентами.
            Властивість children автоматично доступна в кожному компоненті, його вмістом є
            те, що стоїть між відкриваючим та закриваючим JSX-тегом.
            У функціональних компонентах звертаємось як props.children.
            Значенням props.children може бути практично будь-що.
        </p>
        <h2>Властивість defaultProps</h2>
        <p>Що якщо компонент чекає на якесь значення, а його не передали? - при
            зверненні до якості об'єкта props, отримаємо undefined.
            Для того щоб вказати значення властивостей за замовчуванням, компоненти
            мають статичну властивість defaultProps, в якій можна вказати об'єкт з
            дефолтними значеннями пропів (не обов'язково всіх). Цей об'єкт буде злитий з
            об'єктом props, що прийшов
        </p>
        <p>const Product = ({ imgUrl, name, price }) => ( <br>
            < div > <br>
            < img src={imgUrl} alt={name} width="640" /> <br>
            < h2 >{name} </> <br>
            < p >Price: {price}$</> <br>
            < button type="button">Add to cart</> <br>
            < /> <br>
            ); <br>
            Product.defaultProps = { <br>
            imgUrl:'https://тут_посилання_на_фото',};
        </p>
        <h2>Рендер за умовою</h2>
        <p>Для рендеру розмітки за умовою використовуються оператори розгалужень та
            умов. Умови можна перевіряти перед поверненням розмітки або прямо в JSX.
            Якщо за умовою нічого не повинно бути відрендеровано, можна повернути null,
            undefined чи false, вони не рендеряться. <br>
            if за допомогою логічного оператора && <br>
            const Mailbox = ({ unreadMessages }) => ( <br>
            < div> <br>
            < h1 >Hello!< /h1> <br>
            {unreadMessages.length > 0 && ( <br>
            < p >You have {unreadMessages.length} unread messages.<p /p > <br>
            )} <br>
            </> <br>
            );
        </p>
        <p>
            if...else за допомогою тернарного оператора <br>
            const Mailbox = ({ name, unreadMessages }) => ( <br>
            < div > <br>
            < h1>Hello {name}.< /h1> <br>
            {unreadMessages.length > 0 ? ( <br>
            < p>You have {unreadMessages.length} unread messages.< /p> <br>
            ) : ( <br>
            < p >No unread messages.< /p> <br>
            )} <br>
            < /div >
            )
        </p>
        <p> або <br>
            const Mailbox = ({ name, unreadMessages }) => ( <br>
            < div> <br>
            < h1>Hello {name}.< /h1> <br>
            < p> <br>
            {unreadMessages.length > 0 <br>
            ? `You have ${unreadMessages.length} unread messages.` <br>
            : 'No unread messages.'} <br>
            < /p> <br>
            < /div> <br>
            );
        </p>
        <h2>Ознайомлення з Хуками</h2>
        <p>Хуки — це новинка в React 16.8. Вони дозволяють вам використовувати стан та
            інші можливості React без написання класу.</p>
        <pre>
            <code>
                import React, &#123; useState &#125; from 'react';
    
                function Example() &#123;
                    // Створюємо нову змінну стану, яку назвемо "count"
                    const [count, setCount] = useState(0);
    
                    return (
                        &lt;div&gt;
                            &lt;p&gt;Ви натиснули {count} разів&lt;/p&gt;
                            &lt;button onClick=&#123;() => setCount(count + 1)&#125;&gt;Натисни мене&lt;/button&gt;
                        &lt;/div&gt;
                    );
                &#125;
    
                // Нова функція useState є першим “хуком”.
            </code>
        </pre>
        <h2>Хук стану</h2>
    <p>Розглянемо приклад, в якому рендериться лічильник. Коли ви натискаєте кнопку, значення лічильника збільшується:</p>

    <pre>
        <code>
            import React, &#123; useState &#125; from 'react';

            function Example() &#123;
                // Оголошуємо нову змінну стану "count"
                const [count, setCount] = useState(0);

                return (
                    &lt;div&gt;
                        &lt;p&gt;Ви натиснули &#123;count&#125; разів&lt;/p&gt;
                        &lt;button onClick=&#123;() => setCount(count + 1)&#125;&gt;Натисни мене&lt;/button&gt;
                    &lt;/div&gt;
                );
            &#125;

            // Нова функція useState є першим “хуком”.
        </code>
    </pre>
    <p>У цьому прикладі, useState — це хук (визначення хуку наведенно нижче). Ми
        викликаємо його для того, щоб надати внутрішній стан нашому компоненту.
        React буде зберігати цей стан між повторними рендерами. Виклик useState
        повертає дві речі: поточне значення стану та функцію, яка дозволяє оновлювати
        цей стан. Ви можете викликати цю функцію де завгодно, наприклад, в
        обробнику події. Вона подібна до this.setState у класах, за винятком того, що не
        об’єднує новий та старий стан. Порівняння хука useState та this.state приведено
        на сторінці Використання хука стану.
        Єдиним аргументом для useState є початкове значення стану. У наведеному
        вище прикладі — це 0, тому що наш лічильник починається з нуля. Зауважте, що
        на відміну від this.state, у нашому випадку стан може, але не зобов’язаний, бути
        об’єктом. Початкове значення аргументу використовується тільки під час
        першого рендера.
    </p>
    <h2>Оголошення декількох змінних стану</h2>
    <p>Ви можете використовувати хук стану більше одного разу в одному компоненті:</p>

    <pre>
        <code>
            function ExampleWithManyStates() &#123;
                // Оголошуємо декілька змінних стану!
                const [age, setAge] = useState(42);
                const [fruit, setFruit] = useState('банан');
                const [todos, setTodos] = useState([{ text: 'Вивчити хуки' }]);
                // ...
            &#125;
        </code>
    </pre>
    <p>Синтаксис деструктуризації масивів дозволяє нам по різному називати змінні
        стану, які ми оголошуємо при виклику useState. Ці імена не є частиною API
        useState. Натомість, React припускає, що якщо ви викликаєте useState багато
        разів, то ви робите це в тому ж порядку під час кожного рендеру. Ми пояснимо,
        чому це працює та коли це стане в нагоді, трохи пізніше
    </p>
    <p>Що ж таке хук? <br>
        Хуки — це функції, за допомогою яких ви можете “зачепитися” за стан та
        методи життєвого циклу React з функційних компонентів. Хуки не працюють
        всередині класів — вони дають вам можливість використовувати React без
        класів. (Ми не рекомендуємо відразу ж переписувати наявні компоненти, але
        за бажанням, ви можете почати використовувати хуки у своїх нових
        компонентах.) <br>
        React містить кілька вбудованих хуків, таких як useState. Ви також можете
        створювати власні хуки, щоб повторно використовувати їх в інших своїх
        компонентах. Для початку, розглянемо вбудовані хуки.
    </p>
    <h2>Хук ефекту</h2>
    <p>Вам, напевно, доводилося створювати запити даних, робити підписки або
        вручну змінювати DOM з React-компонента. Ми називаємо ці операції
        “побічними ефектами” (або скорочено “ефекти”), так як вони можуть впливати на
        роботу інших компонентів і не можуть бути виконані під час рендеринга.
        За допомогою хука ефекту useEffect ви можете виконувати побічні ефекти із
        функційного компонента. Він виконує таку ж саму роль, що і
        componentDidMount, componentDidUpdate та componentWillUnmount у Reactкласах, об’єднавши їх в єдиний API. (Ми порівняємо useEffect з іншими
        методами на сторінці Використання хука ефекту.)
        Наприклад, цей компонент встановлює заголовок документа після того, як React
        оновлює DOM:
    </p>
    <pre>
        <code>
            import React, &#123; useState, useEffect &#125; from 'react';

            function Example() &#123;
                const [count, setCount] = useState(0);

                useEffect(() => &#123;
                    document.title = `Ви натиснули ${count} разів`;
                &#125;);

                return (
                    &lt;div&gt;
                        &lt;p&gt;Ви натиснули {count} разів&lt;/p&gt;
                        &lt;button onClick=&#123;() => setCount(count + 1)&#125;&gt;
                            Натисни мене
                        &lt;/button&gt;
                    &lt;/div&gt;
                );
            &#125;
        </code>
    </pre>
    <p>Коли ви викликаєте useEffect, React отримує вказівку запустити вашу функцію з
        “ефектом” після того, як він відправив зміни у DOM. Оскільки ефекти
        оголошуються всередині компонентів, то у них є доступ до пропсів та стану. За
        замовчуванням, React запускає ефекти після кожного рендеру, включаючи
        перший рендер. (Ми розглянемо більш докладно, як це відрізняється від
        класових методів життєвого циклу на сторінці Використання ефекту хука.)
        Ефект також може повертати функцію, яка вказуватиме, як за ним слід здіснити
        “прибрання”. Наприклад, цей компонент використовує ефект, щоб підписатися
        на статус друга в мережі, і виконує прибирання, відписуючись від нього:
    </p> 
    <pre>
        <code>
            import React, &#123; useState, useEffect &#125; from 'react';

            function FriendStatus(props) &#123;
                const [isOnline, setIsOnline] = useState(null);

                function handleStatusChange(status) &#123;
                    setIsOnline(status.isOnline);
                &#125;

                useEffect(() => &#123;
                    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
                    return () => &#123;
                        ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
                    &#125;;
                &#125;, [props.friend.id]);

                if (isOnline === null) &#123;
                    return 'Завантаження...';
                &#125;

                return isOnline ? 'В мережі' : 'Не в мережі';
            &#125;
        </code>
    </pre>
    </body>
</html>