<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-6</title>
</head>
<body>
    <h2>Хуки</h2>
    <p>Hooks в React - це нове додаткове API, представлене в React 16.8, яке дозволяє використовувати стан, контекст, побічні ефекти та інші
        можливості React в функціональних компонентах. Раніше, для реалізації таких функціональностей, необхідно було використовувати класові
        компоненти.
    </p>
    <p>Hooks надають можливість розширити функціональні
        компоненти, додаючи до них стан та поведінку, що раніше
        була доступна лише в класових компонентах.
        Використовуючи Hooks, розробники можуть писати
        компоненти в більш декларативному та функціональному
        стилі, спрощуючи розробку та розуміння коду.
    </p>
    <p>Hooks відкривають нові можливості для створення і
        управління функціональними компонентами в React,
        дозволяючи писати більш чистий, зрозумілий та
        ефективний код. Вони стали важливою частиною
        екосистеми React та допомогли зробити функціональні
        компоненти ще потужнішими.
    </p>
    <h2>useEffect</h2>
    <p>useEffect є одним з найбільш популярних хуків у React-екосистемі. Він використовується для виконання побічних ефектів (side
        effects) в компонентах React, таких як запити до сервера, підписка на події, маніпуляції з DOM тощо. Хук useEffect дозволяє
        вказати функцію, яка буде виконана після кожного рендерингу компонента або при зміні певних залежностей
    </p>
    <p>Основний синтаксис useEffect виглядає наступним чином:
        Першим параметром useEffect приймається callback функція, усередині
        якої виконується вся логіка ефекту. Наприклад, запити на сервер, завдання
        обробників подій на документ і т.п. яка виконує побічний ефект. <br>
        Другим параметром є масив залежностей - масив змінних, при зміні будьякого з яких, буде запускатися ефект і виконуватися callback. Це може бути
        стан, пропси або будь-яке локальне значення всередині компонента.
        Масив залежностей вказує, при яких змінах цей ефект має бути виконаний
        знову. Якщо масив залежностей порожній, побічний ефект виконується
        тільки після першого рендерингу компонента.
    </p>
    <h2>useEffect vs Class life cycle methods </h2>
    <p>Хук useEffect викликається в різних етапах життєвого циклу компонента. Порівняємо його з класовими життєвими циклами: <br>
        Монтаж (Mounting): <br>
        useEffect викликається після першого рендерингу компонента (аналог componentDidMount у класових компонентах).
        Оновлення (Updating): <br>
        При кожному оновленні компонента useEffect викликається після повторного рендерингу (аналог componentDidUpdate у класових
        компонентах). <br>
        Якщо в масиві залежностей передані змінні, зміна яких спричиняє оновлення, то useEffect буде викликано лише при зміні цих
        залежностей. <br>
        Розмонтування (Unmounting): <br>
        Перед тим, як компонент буде розмонтований (видалений з DOM), useEffect викликається зі спеціальною функцією очищення (аналог
        componentWillUnmount у класових компонентах). <br>
        Функція очищення, яка передається як повернення з useEffect, виконується перед розмонтуванням компонента.
    </p>
    <h2>useLayoutEffect vs useEffect</h2>
    <p>useLayoutEffect і useEffect - це два хуки в React, які використовуються для виконання побічних ефектів. Обидва хуки працюють подібно, але є
        і ключові різниці в тому, коли вони викликаються.
    </p>
    <p>useEffect: <br>
        - Викликається після відображення змінного стану на екрані (після фази рендерингу та перфектування браузера). <br>
        - Це асинхронний хук, тому він не блокує рендеринг компонента. <br>
        - Зазвичай використовується для виконання побічних ефектів, таких як взаємодія з DOM, запити до сервера, підписки на події тощо. <br>
        - Може бути викликано під час першого рендерингу компонента та після кожного оновлення (якщо передані залежності). <br>
        - Це рекомендований хук для більшості ситуацій.
    </p>
    <p>useLayoutEffect: <br>
        - Викликається після відображення змінного стану на екрані, але перед тим, як браузер оновить екран. <br>
        - Це синхронний хук, тому він блокує рендеринг компонента до завершення побічного ефекту. <br>
        - Використовується, коли потрібно отримати оновлені виміри елементів або зробити зміни в DOM перед оновленням екрану. <br>
        - Може призвести до затримки рендерингу, тому його потрібно використовувати обережно. <br>
        - Зазвичай використовується в спеціалізованих ситуаціях, коли потрібно точно контролювати момент виконання побічного ефекту
    </p>
    <h2>useLayoutEffect</h2>
    <p>Припустимо, у вас є компонент React, який має внутрішній елемент, наприклад, <div>, і ви хочете отримати його висоту після рендерингу та зробити
        на цій основі деякі додаткові дії. Однак, пам'ятайте, що під час рендерингу браузеру деякі стилі можуть ще не бути застосовані до DOM-елемента.
        В таких випадках використання useLayoutEffect замість useEffect може бути доцільним, оскільки useLayoutEffect викликається синхронно
        після оновлення DOM, перед тим, як браузер виконає наступний крок в рендерингу. Це дає вам можливість отримати оновлені виміри елемента або
        зробити зміни в DOM, використовуючи отриману інформацію про висоту елемента.
    </p>
    <h2>useState</h2>
    <p>Хук useState є одним з основних хуків в React і використовується для створення та оновлення стану в компонентах.
        useState приймає початкове значення стану та повертає масив з двома елементами: поточне значення стану та функцію, яку можна
        використовувати для зміни значення стану.
    </p>
    <p>У хуці useState ви можете використовувати prevState, щоб отримати попереднє значення стану при оновленні. Це корисно, коли нове
        значення стану залежить від попереднього значення
    </p>
    <p>Використання prevState у хуці useState має кілька переваг:</p>
    <p>Гарантія правильності оновлення стану: Коли ви використовуєте prevState у функції оновлення стану, ви отримуєте доступ до
        оригінального значення стану. Це дозволяє уникнути потенційних проблем зі станом, які можуть виникнути через асинхронність оновлення
        стану в React
    </p>
    <p>Правильна робота зі станом, залежним від попереднього значення: Коли нове значення стану залежить від попереднього значення,
        використання prevState дозволяє гарантувати, що ви працюєте з актуальним значенням стану на момент оновлення. Це особливо корисно,
        коли у вас є декілька послідовних оновлень стану, які залежать одне від одного.
    </p>
    <p>Ефективність: Використання prevState у хуці useState допомагає забезпечити ефективне оновлення стану. React може злити кілька
        оновлень стану разом, що дозволяє уникнути зайвих перерендерів компонента.
    </p>
    <p>Однак, важливо зазначити, що використання prevState не є обов'язковим у всіх випадках. Якщо ваше оновлення стану не залежить від
        попереднього значення, ви можете просто передати нове значення setState без використання prevState.
        Загалом, використання prevState у хуці useState рекомендується, коли ви маєте справу зі станом, який змінюється залежно від попереднього
        значення. Це сприяє правильності та ефективності оновлення стану в компонентах React.
    </p>
    <h2>useReducer</h2>
    <p>Хук useReducer є альтернативою хуку useState і використовується для управління
        складним станом компонента, особливо коли стан має складну структуру або вимагає
        багатьох взаємозалежних оновлень. Він дозволяє вам використовувати патерн
        "reducer" знайомого з Redux
    </p>
</body>
</html>