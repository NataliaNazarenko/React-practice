<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-3</title>
</head>
<body>
    <h2>Multiple-page application</h2>
    <p>Це підхід який включає декілька окремих HTML-сторінок.</p>
    <p>• Архітектура клієнт-сервер
        • Вся логіка живе на сервері
        • На кожен запит сервер надсилає готовий HTML-документ
        • Перезавантаження сторінки при кожному запиті
        • Погана інтерактивність
        • Відмінне SEO
    </p>
    <h2>Single-page application</h2>
    <p>Сучасний підхід – сайт, на якому користувач ніколи не переходить на інші
        HTML-сторінки. Інтерфейс, замість запиту HTML-документів з сервера,
        перемальовується на клієнті, на одній і тій самій сторінці, без
        перезавантаження.
    </p>
    <p>• Архітектура клієнт-сервер
        • При завантаженні сайту сервер завжди віддає стартову HTML-сторінку index.html
        • Кожен наступний запит на сервер отримує лише дані у JSON-форматі
        • Оновлення інтерфейсу відбувається динамічно на клієнті
        • Завантаження першої сторінки може бути досить повільним (лікується додатковими фреймворками)
        • Логіка, не пов'язана із безпекою, живе на клієнті
        • Слабке SEO (лікується через Next.js)
        • Складність коду та його підтримки масштабується з кількістю функціоналу застосунку
    </p>
    <h2>Рендер компонентів Virtual DOM</h2>
    <p> • Що таке DOM (Document Object Model)
        Обʼєктне представлення вмісту HTML документу та інтерфейс для управління цим обʼєктом 
    </p>
    <p>• DOM API (Application programming interface)
        Якщо ми хочемо змінити вміст першого елементу “list”, будемо використовувати DOM API
    </p>
    <p>З кожною зміною DOM браузер виконує кілька трудомістких
        операцій. Часті операції оновлення такого дерева негативно
        впливають на продуктивність та реакцію інтерфейсу. Тому він
        повільний, та оновлювати його необхідно ефективно.
    </p>
    <p>Virtual DOM можна розглядати, як копію звичайного DOM, яку
        можна часто оновлювати. Після внесення усіх змін до Virtual
        DOM, ми бачимо, які зміни слід внести у DOM та здійснити їх
        більш направлено та ефективно.
    </p>
    <p>• Як працює VDOM під капотом.</p>
    <p>У React кожен елемент інтерфейсу – це компонент (кастомний або
        вбудований), який залежить від пропсів або стану, і представлений вузлами
        віртуального DOM-дерева. Взаємодія користувача з інтерфейсом змінює стан
        застосунку.
    </p>
    <p>• Virtual DOM в React</p>
    <p>Підсумок</p>
    <p>Отже, Virtual DOM — інструмент, що дозволяє взаємодіяти
        з елементами DOM простіше та ефективніше. Virtual DOM
        представлено у вигляді об'єкта Javascript, який ми
        можемо змінювати так часто, як нам потрібно. Зміни,
        здійснені над об'єктом накопичуються, а фактичний DOM
        оновлюється направлено та рідшe.
    </p>
    <h2>State</h2>
    <p>State – це концепція в React в якій міститься інформація, що впливає на результат рендерингу</p>  
    <p>Стан (state) є одним з основних понять в React і використовується для збереження та управління даними в компонентах React. Стан
        представляє собою об'єкт, який містить дані, які можуть змінюватись протягом життєвого циклу компонента. Коли стан змінюється, React
        автоматично оновлює відображення компонента, що призводить до оновлення користувацького інтерфейсу.
    </p>
    <p>Основні принципи роботи зі станом в React:</p>
    <p>Ініціалізація стану: Стан можна ініціалізувати в конструкторі класового компонента або за допомогою хука useState в
        функціональному компоненті.
    </p>
    <p>Отримання значення стану: Для отримання значення стану використовуйте this.state у класових компонентах або просту змінну, отриману в
        результаті виклику хука useState, у функціональних компонентах.
    </p>
    <p>Зміна стану: Для зміни стану використовуйте метод setState у класових компонентах або
        функцію, отриману в результаті виклику хука useState, у функціональних компонентах.
        Важливо пам'ятати, що стан у React є незмінним, тому ви не повинні змінювати його напряму.
        Замість цього, ви повинні створювати новий об'єкт, який містить оновлені дані стану. 
    </p>
    <p>Нове значення стану можна обчислювати на основі поточного значення стану або інших
        даних. В класових компонентах метод setState приймає об'єкт з оновленими значеннями
        властивостей стану або функцію, яка приймає поточний стан і возвращает об'єкт з
        оновленими значеннями. У функціональних компонентах функція, отримана від useState,
        приймає нове значення стану або функцію, яка приймає поточне значення стану і повертає
        нове значення.
    </p>
    <p>Асинхронність оновлення стану: Оновлення стану в React може бути
        асинхронним, тому не можна покладатися на негайну зміну значення стану після
        виклику setState або функції стану. Якщо вам потрібно виконати певну дію
        після оновлення стану, ви можете використовувати колбек-функцію, передану у
        setState (у класових компонентах) або використовувати ефекти (у
        функціональних компонентах).
    </p>
    <p>Розширений стан: Стан в React може бути об'єктом, який містить більше
        однієї властивості. Ви можете додати додаткові властивості до стану і
        оновлювати їх незалежно один від одного.
    </p>
    
</body>
</html>