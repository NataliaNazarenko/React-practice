<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-3</title>
</head>
<body>
    <h2>Multiple-page application</h2>
    <p>Це підхід який включає декілька окремих HTML-сторінок.</p>
    <p>• Архітектура клієнт-сервер
        • Вся логіка живе на сервері
        • На кожен запит сервер надсилає готовий HTML-документ
        • Перезавантаження сторінки при кожному запиті
        • Погана інтерактивність
        • Відмінне SEO
    </p>
    <h2>Single-page application</h2>
    <p>Сучасний підхід – сайт, на якому користувач ніколи не переходить на інші
        HTML-сторінки. Інтерфейс, замість запиту HTML-документів з сервера,
        перемальовується на клієнті, на одній і тій самій сторінці, без
        перезавантаження.
    </p>
    <p>• Архітектура клієнт-сервер
        • При завантаженні сайту сервер завжди віддає стартову HTML-сторінку index.html
        • Кожен наступний запит на сервер отримує лише дані у JSON-форматі
        • Оновлення інтерфейсу відбувається динамічно на клієнті
        • Завантаження першої сторінки може бути досить повільним (лікується додатковими фреймворками)
        • Логіка, не пов'язана із безпекою, живе на клієнті
        • Слабке SEO (лікується через Next.js)
        • Складність коду та його підтримки масштабується з кількістю функціоналу застосунку
    </p>
    <h2>Рендер компонентів Virtual DOM</h2>
    <p> • Що таке DOM (Document Object Model)
        Обʼєктне представлення вмісту HTML документу та інтерфейс для управління цим обʼєктом 
    </p>
    <p>• DOM API (Application programming interface)
        Якщо ми хочемо змінити вміст першого елементу “list”, будемо використовувати DOM API
    </p>
    <p>З кожною зміною DOM браузер виконує кілька трудомістких
        операцій. Часті операції оновлення такого дерева негативно
        впливають на продуктивність та реакцію інтерфейсу. Тому він
        повільний, та оновлювати його необхідно ефективно.
    </p>
    <p>Virtual DOM можна розглядати, як копію звичайного DOM, яку
        можна часто оновлювати. Після внесення усіх змін до Virtual
        DOM, ми бачимо, які зміни слід внести у DOM та здійснити їх
        більш направлено та ефективно.
    </p>
    <p>• Як працює VDOM під капотом.</p>
    <p>У React кожен елемент інтерфейсу – це компонент (кастомний або
        вбудований), який залежить від пропсів або стану, і представлений вузлами
        віртуального DOM-дерева. Взаємодія користувача з інтерфейсом змінює стан
        застосунку.
    </p>
    <p>• Virtual DOM в React</p>
    <p>Підсумок</p>
    <p>Отже, Virtual DOM — інструмент, що дозволяє взаємодіяти
        з елементами DOM простіше та ефективніше. Virtual DOM
        представлено у вигляді об'єкта Javascript, який ми
        можемо змінювати так часто, як нам потрібно. Зміни,
        здійснені над об'єктом накопичуються, а фактичний DOM
        оновлюється направлено та рідшe.
    </p>
    <h2>State</h2>
    <p>State – це концепція в React в якій міститься інформація, що впливає на результат рендерингу</p>  
    <p>Стан (state) є одним з основних понять в React і використовується для збереження та управління даними в компонентах React. Стан
        представляє собою об'єкт, який містить дані, які можуть змінюватись протягом життєвого циклу компонента. Коли стан змінюється, React
        автоматично оновлює відображення компонента, що призводить до оновлення користувацького інтерфейсу.
    </p>
    <p>Основні принципи роботи зі станом в React:</p>
    <p>Ініціалізація стану: Стан можна ініціалізувати в конструкторі класового компонента або за допомогою хука useState в
        функціональному компоненті.
    </p>
    <p>Отримання значення стану: Для отримання значення стану використовуйте this.state у класових компонентах або просту змінну, отриману в
        результаті виклику хука useState, у функціональних компонентах.
    </p>
    <p>Зміна стану: Для зміни стану використовуйте метод setState у класових компонентах або
        функцію, отриману в результаті виклику хука useState, у функціональних компонентах.
        Важливо пам'ятати, що стан у React є незмінним, тому ви не повинні змінювати його напряму.
        Замість цього, ви повинні створювати новий об'єкт, який містить оновлені дані стану. 
    </p>
    <p>Нове значення стану можна обчислювати на основі поточного значення стану або інших
        даних. В класових компонентах метод setState приймає об'єкт з оновленими значеннями
        властивостей стану або функцію, яка приймає поточний стан і возвращает об'єкт з
        оновленими значеннями. У функціональних компонентах функція, отримана від useState,
        приймає нове значення стану або функцію, яка приймає поточне значення стану і повертає
        нове значення.
    </p>
    <p>Асинхронність оновлення стану: Оновлення стану в React може бути
        асинхронним, тому не можна покладатися на негайну зміну значення стану після
        виклику setState або функції стану. Якщо вам потрібно виконати певну дію
        після оновлення стану, ви можете використовувати колбек-функцію, передану у
        setState (у класових компонентах) або використовувати ефекти (у
        функціональних компонентах).
    </p>
    <p>Розширений стан: Стан в React може бути об'єктом, який містить більше
        однієї властивості. Ви можете додати додаткові властивості до стану і
        оновлювати їх незалежно один від одного.
    </p>
    <p>Так як працювати доведеться далі в більшості з хуками, то більш детально про useState:</p>
    <p>Виклик хука “useState” створює стан і метод, який змінюватиме його
        значення. У якості параметра хук приймає початковий стан, в нашому випадку
        число 0. У стані може зберігатися будь-який тип даних.
    </p>
    <p>сounter = наше значення стейту <br>
        setCounter = функція за допомогою якої ми можемо змінювати стейт <br>
        useState() = hook який нам надає React для обробки стану компонента <br>
        0 = початковий стан компонента <br>
    </p>
    <p>Ми не можемо змінювати стан компонента напряму</p>
    <p>• Інтерфейс залежить від стану компонента. <br>
        • Стан може змінитися як реакція на дії користувача. <br>
        • Під час зміни стану дані передаються вниз по дереву компонентів. <br>
        • Компоненти повертають оновлену розмітку і змінюється інтерфейс
    </p>
    <h2>Події</h2>
    <p>Для нативної події браузера в React створюється об'єкт-обгортка “SyntheticEvent Object” з ідентичним інтерфейсом. Це необхідно, щоб забезпечити
        крос-браузерність та оптимізувати продуктивність. <br>
        У React події (events) використовуються для обробки дій користувача, таких як натискання кнопок, введення тексту, наведення курсору тощо. React надає
        спеціальний синтаксис для роботи з подіями, який дозволяє додавати обробники подій до елементів інтерфейсу.
    </p>
    <p>Основні принципи роботи з подіями в React:</p>
    <p>Події назначаються в JSX: Ви можете назначити обробник подій безпосередньо в JSX, використовуючи синтаксис подібний до HTML. Наприклад, для назначення
        обробника події натискання кнопки ви можете використати атрибут onClick
    </p>
    <p>Обробники подій: Обробники подій - це функції, які викликаються при виникненні певної події. Вони приймають об'єкт події як параметр і можуть
        містити логіку для обробки події.
    </p>
    <p>Стандартні події: В React ви можете використовувати стандартні події, такі як onClick, onChange, onSubmit тощо, аналогічно до того, як це
        робиться в звичайному JavaScript. Ви також можете використовувати інші події, які підтримуються браузерами.
    </p>
    <p>Обробка подій в класових компонентах: У класових компонентах React
        обробники подій оголошуються як методи класу
    </p>
    <p>Обробка подій в функціональних компонентах: У функціональних компонентах
        React обробники подій можуть бути оголошені як звичайні функції.
    </p>
    <p>Передача додаткових параметрів: Іноді вам може знадобитись передати додаткові параметри до обробника події. В такому випадку
        використовується стрілочна функція або функція з замиканням
    </p>
    <p>Отримання інформації про подію: Об'єкт події, переданий в обробник, містить корисну інформацію про
        подію. Наприклад, ви можете отримати значення введеного тексту в поле вводу або отримати координати
        курсору миші.
    </p>
    <p>Відміна події: У React ви можете відмінити стандартну поведінку події,
        якщо ви хочете заборонити певні дії. Для цього викликайте метод
        preventDefault() на об'єкті події.
    </p>
    <p>• Додавання обробника подій з EventTarget.addEventListener() майже не використовується, за рідкісним винятком. <br>
        • Пропси подій – не виняток та іменуються за допомогою camelCase. Наприклад onClick, onChange, onSubmit, onMouseEnter. <br>
        • У проп події передається посилання на callback-функцію, яка буде викликана під час настання події. <br>
        • Обробники подій отримують екземпляр SyntheticEvent Object.
    </p>
    <p>В React "під капотом" реалізовано делегування подій. Слухачі не додаються безпосередньо до DOM-елементів. Передача колбека – це
        просто реєстрація функції, яка буде викликана внутрішніми механізмами реакта під час настання події.
    </p>
</body>
</html>