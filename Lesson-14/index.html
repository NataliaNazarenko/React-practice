<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-14</title>
</head>
<body>
    <h1>Redux, Redux toolkit</h1>
    <h2>createSlice, configureStore</h2>
    <p>Redux Toolkit використовує підхід до розділення стану за допомогою "slices". Створення slice - це спосіб групувати пов'язані дії та редюсери разом. 
    </p>
    <p>Redux Toolkit також надає функцію configureStore, яка автоматично виконує багато стандартних операцій настроювання.</p>
    <h2>Provider</h2>
    <p>Після створення store ви можете підключити його до свого додатку.</p>
    <h2>useDispatch()</h2>
    <p>Метод useDispatch() в React Redux Toolkit - це спеціальна функція-хук, яка надає можливість виконувати диспетчеризацію (dispatch) дій (actions)
        у вашому компоненті React, коли ви використовуєте Redux Toolkit для керування станом вашого додатка.
    </p>
    <p>В Redux Toolkit диспетчеризація дій відбувається за допомогою Redux store, який зберігає стан додатка. Для виконання диспетчеризації дій
        потрібно мати доступ до об'єкта store або мати можливість отримати доступ до нього.
    </p>
    <p>Завдяки useDispatch(), вам не потрібно прямо отримувати доступ до store в компоненті. Замість цього ви можете використовувати
        useDispatch() для отримання функції диспетчеризації дій, яку ви можете використовувати для виклику дій Redux.
    </p>
    <p>У цьому прикладі useDispatch() використовується для отримання
        функції диспетчеризації дій, яка прив'язана до об'єкта store. У нашому
        компоненті ми визначаємо функцію handleClick(), яка викликає
        диспетчеризацію дії myAction() за допомогою
        dispatch(myAction()). При кліку на кнопку "Dispatch Action" буде
        виконано диспетчеризацію дії myAction().
    </p>
    <p>Отримання доступу до функції диспетчеризації дій за допомогою
        useDispatch() дозволяє зручно і просто керувати станом вашого
        додатка в компонентах React, які використовують Redux Toolkit.
    </p>
    <h2>useSelector()</h2>
    <p>Для того, щоб отримати дані зі стору Redux та використовувати їх у компонентах, ви можете використовувати хук useSelector() з бібліотекою
        react-redux.
    </p>
    <p>У функції useSelector ви передаєте колбек-функцію, яка
        отримує поточний стан стору як аргумент і повертає потрібні
        дані. В прикладі вище ми отримуємо дані з ключем data зі
        стору.
    </p>
    <p>В прикладі ми використовуємо отримані дані зі стору для
        відображення заголовку (data.title) та опису (data.description) у
        компоненті.
    </p>
    <p>Важливо відмітити, що ви можете використовувати хук useSelector в будь-якому компоненті, який обгортається компонентою <Provider> з
        react-redux. Цей хук автоматично підписує компонент на зміни стану стору, тому компонент буде оновлюватись, коли дані змінюються у сторі
        Redux
    </p>
    <h2>createSelector()</h2>
    <p>createSelector - це функція з бібліотеки redux-toolkit, яка використовується для створення мемоізованих селекторів в Redux. Вона дозволяє ефективно
        обчислювати похідні дані зі стану вашого Redux-стору, забезпечуючи кешування результатів, що покращує продуктивність додатку.
    </p> 
    <p>У Redux ви можете мати ситуації, коли вам потрібно обчислювати похідні дані зі стану, наприклад, фільтрувати, сортувати або групувати дані перед їхнім
        використанням в компоненті. Без мемоізації ці обчислення можуть повторюватися надто часто, що призводить до зайвої роботи і зниження
        продуктивності.
    </p>
    <p>У прикладі ми використовуємо два вхідних селектори -
        getUsers і getFilter - для отримання відповідних частин стану.
        Потім визначаємо функцію, яка обчислює відфільтрований список
        користувачів на основі цих даних.
    </p>
    <p>Замість прямого використання getUsers і getFilter, ви використовуєте filteredUsersSelector як селектор для отримання відфільтрованого
        списку користувачів. Селектор буде повертати результат з кешу, якщо вхідні дані не змінилися, зменшуючи непотрібні повторні обчислення.
    </p>
</body>
</html>