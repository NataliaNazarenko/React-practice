<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-9/title>
</head>
<body>
    <h2>Неконтрольовані елементи</h2>
    <p>Основна мета будь-якої форми – отримати дані користувача. Для цього під час сабміту можна отримати значення полів
        з її властивості elements або, використовуючи FormData. Такий прийом доречно використовувати, коли дані полів
        форми потрібні тільки під час її сабміту.
    </p>
    <p>Неконтрольовані елементи використовуються тоді, коли значення елементів форми зберігається в DOM. Компонент не контролює ці
        значення безпосередньо. При цьому значення елемента може змінюватися користувачем, і компонент не буде про це знати. Щоб
        отримати значення, потрібно звертатися до DOM.
    </p>
    <p>Є декілька варіантів обробки неконтрольованих елементів форм:</p>
    <p>Пререхоплення обʼєкта подій “event”</p>
    <p>За допомогою хука “useRef”</p>
    <h2>Контрольовані елементи</h2>
    <p>Контрольовані елементи форми (Controlled Components) в React це елементи форми, для яких значення та стан контролюється
        React компонентом. Це означає, що стан елемента форми зберігається в стані компонента React, а його зміна відбувається
        через обробники подій. Контрольовані елементи дозволяють реагувати на зміни значень, валідувати введені дані та виконувати
        додаткові дії перед відправкою форми.
    </p>
    <p>Основна ідея контрольованих елементів полягає в тому, що значення елемента форми повинне відображати його стан в стані
        компонента React, а зміни значення елемента викликають обновлення стану компонента. Це дозволяє реагувати на зміни значень,
        виконувати валідацію, встановлювати значення за замовчуванням і здійснювати інші дії контролю над елементами форми
    </p>
    <p>Контрольовані елементи форми в React дозволяють зберігати значення елементів
        форми у стані компонента та реагувати на зміни значень за допомогою обробників подій
    </p>
    <p>Такий підхід до роботи з формами надає багато переваг. Наприклад</p>
    <p>• Значення елементів форми зберігаються у централізованому стані компонента, що полегшує управління та синхронізацію
        значень.
        • Можна виконувати валідацію введених даних, перевіряти на належність певному формату і реагувати на помилки.
        • Значення елементів легко синхронізувати з іншими компонентами або використовувати для відправки на сервер.
        • Компонент повністю контролює значення елементів, що дозволяє здійснювати додаткову обробку перед відправкою
        форми, наприклад, валідацію або підготовку даних.
    </p>
    <p>Таким чином, контрольовані елементи форми в React дозволяють більшу гнучкість та контроль над взаємодією з формами,
        роблять їх легкими у використанні та дозволяють забезпечити надійну та попередньо валідовану обробку введених даних.
    </p>
    <h2>Чекбокси</h2>
    <p>У JSX-частині компонента ми маємо елемент <input> з типом checkbox.
        Атрибут checked пов'язаний зі станом checked, що забезпечує відображення
        правильного стану чекбоксу на основі значення стану. Також,
        використовується обробник onChange, який викликається при зміні стану
        чекбоксу. <br>
        Отже, коли користувач вибирає або знімає позначку чекбоксу, викликається
        обробник handleCheckboxChange, який оновлює стан checked. І навпаки,
        якщо стан checked змінюється, чекбокс автоматично оновлюється, щоб
        відображати актуальний стан.
    </p>
    <h2>Радіокнопки</h2>
    <p>У JSX-частині компонента ми маємо елементи <input> з типом radio. Кожен елемент має
        своє унікальне значення, яке встановлене за допомогою атрибута value. Наприклад, у
        прикладі ми маємо три радіокнопки зі значеннями "option1", "option2" і “option3". <br>
        Атрибут checked кожного <input> пов'язаний зі станом selectedOption. Це забезпечує
        правильне відображення вибраної радіокнопки на основі значення стану. Наприклад, якщо
        selectedOption має значення "option2", то радіокнопка з value="option2" буде
        відображена як вибрана.
    </p>
    <p>Обробник події onChange викликається при зміні стану радіокнопок. У нашому прикладі,
        він викликає функцію handleOptionChange, яка оновлює стан selectedOption залежно
        від значення вибраної радіокнопки (event.target.value). <br>
        Таким чином, коли користувач вибирає іншу радіокнопку, викликається обробник
        handleOptionChange, який оновлює стан selectedOption з відповідним значенням. В
        результаті, радіокнопки відображають актуальний стан вибору. <br>
        За допомогою цього підходу до роботи з радіокнопками, ви можете контролювати стан
        вибору, отримувати значення з вибраних радіокнопок і виконувати додаткову логіку на
        основі вибору користувача.
    </p>
    <h2>Селект</h2>
    <p>У прикладі ми використовуємо два стани selectedOption1 і selectedOption2
        для збереження вибраних значень у першому і другому тег select відповідно.
        Для кожного select ми використовуємо атрибут value, який пов'язаний з
        відповідним станом і визначає, яке значення має бути вибране у випадаючому списку.
        Обробник onChange викликається при зміні вибраного значення і оновлює стан
        selectedOption1 або selectedOption2 відповідно до зміненого значення.
        При надсиланні форми (submit), викликається функція handleSubmit. Ви можете
        використовувати значення selectedOption1 і selectedOption2 для виконання
        певних дій або для відправки на сервер. В даному прикладі, можна використовувати
        значення selectedOption1 і selectedOption2 для подальшої обробки, наприклад,
        для здійснення вибору опцій або для виконання певних дій на основі вибору
        користувача.
    </p>
    <p>Наступний приклад дозволяє гнучко налаштувати елементи option у select за
        допомогою мапування масиву об'єктів. Ви можете легко додавати, видаляти або
        змінювати елементи options, і елемент select автоматично оновлюватиметься
        згідно зі змінами.
        У цьому прикладі ми використовуємо масив options, який містить об'єкти зі
        значеннями та мітками для елементів option. За допомогою функції map, ми
        перебираємо цей масив та створюємо елемент option для кожного об'єкта у
        масиві. Кожен елемент option має унікальний ключ key (в нашому випадку
        використовується значення option.value) і встановлює значення та мітку з
        відповідного об'єкта option.
        При зміні вибраного значення, обробник handleOptionChange оновлює стан
        selectedOption з новим значенням. При надсиланні форми (submit), викликається
        функція handleSubmit, в якій ви можете використовувати значення
        selectedOption для подальшої обробки або відправки на сервер.
    </p>
    <h2>Обробка комплексної форми</h2>
    <p>У прикладі ми використовуємо хук useState для
        створення стану formState, який є об'єктом із
        початковими значеннями для кожного поля форми.
        Кожен елемент форми має свій обробник подій,
        наприклад, handleOptionChange, handleTextChange,
        handleCheckboxChange, які оновлюють відповідне поле
        у стані formState з новим значенням. Ми
        використовуємо функціональну форму setFormState,
        щоб оновити стан, використовуючи попередній стан.
    </p>
    <p>При надсиланні форми, викликається функція handleSubmit, в якій ви можете використовувати значення форми з об'єкта formState, наприклад
        ви можете використовувати значення форми з об'єкта formState для виконання потрібних дій або передачі їх до інших компонентів. Наприклад, ви
        можете вивести значення форми на екран або відправити їх на сервер.
        У прикладі після надсилання форми ми отримуємо значення
        selectedOption, textInput та checkboxChecked з об'єкта
        formState. Ми можемо використовувати їх, наприклад, для
        виведення їх у консоль або для виконання інших потрібних дій.
        Залежно від вашого випадку використання, ви можете замість
        виводу в консоль виконувати різні дії зі значеннями форми, такі як
        відправлення на сервер, оновлення стану компонента або
        виконання додаткової логіки на основі вибраних опцій.
    </p>
    <h2>Використання Debounce у формі</h2>
    <p>Debounce - це техніка, яка дозволяє затримати виконання функції на певний період після того, як відбулася остання подія. В контексті форм,
        debounce може бути використаний для затримки виконання функції зв'язаної з формою (наприклад, валідація або відправлення на сервер), до тих
        пір, поки користувач не завершить введення або не зупиниться. <br>
        Debounce може бути корисним в ситуаціях, коли ви хочете зменшити навантаження на сервер або забезпечити плавну інтерактивність для
        користувача, не виконуючи функцію з кожним введенням. 
    </p>
    <p>Застосуємо debounce на події onChange форми. При кожному введенні користувача, ми будемо викликати функцію handleChange з
        затримкою, використовуючи debounce. Це допоможе уникнути частого виконання функції при швидкому введенні та поліпшити продуктивність
        програми.
    </p>
    <p>В прикладі функція handleChange є обгорткою для функції
        setInputValue, яку ми оточуємо debounce. При кожному введенні
        користувача, handleChange буде викликатись з затримкою 500 мс.
        Таким чином, якщо користувач продовжує вводити, функція
        setInputValue не буде виконуватись негайно. Замість цього, вона буде
        виконана лише після 500 мс з моменту останнього вводу користувача. Це
        дозволяє затримати оновлення значення inputValue та виконання
        додаткових дій, які можуть бути пов'язані зі значеннями форми.
        Цей підхід може бути корисним, наприклад, при реалізації пошуку на основі
        введення користувача, де ви хочете виконати пошук тільки після того, як
        користувач завершить введення або зупиниться на деякий час.
    </p>
</body>
</html>