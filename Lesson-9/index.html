<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-9/title>
</head>
<body>
    <h2>Неконтрольовані елементи</h2>
    <p>Основна мета будь-якої форми – отримати дані користувача. Для цього під час сабміту можна отримати значення полів
        з її властивості elements або, використовуючи FormData. Такий прийом доречно використовувати, коли дані полів
        форми потрібні тільки під час її сабміту.
    </p>
    <p>Неконтрольовані елементи використовуються тоді, коли значення елементів форми зберігається в DOM. Компонент не контролює ці
        значення безпосередньо. При цьому значення елемента може змінюватися користувачем, і компонент не буде про це знати. Щоб
        отримати значення, потрібно звертатися до DOM.
    </p>
    <p>Є декілька варіантів обробки неконтрольованих елементів форм:</p>
    <p>Пререхоплення обʼєкта подій “event”</p>
    <p>За допомогою хука “useRef”</p>
    <h2>Контрольовані елементи</h2>
    <p>Контрольовані елементи форми (Controlled Components) в React це елементи форми, для яких значення та стан контролюється
        React компонентом. Це означає, що стан елемента форми зберігається в стані компонента React, а його зміна відбувається
        через обробники подій. Контрольовані елементи дозволяють реагувати на зміни значень, валідувати введені дані та виконувати
        додаткові дії перед відправкою форми.
    </p>
    <p>Основна ідея контрольованих елементів полягає в тому, що значення елемента форми повинне відображати його стан в стані
        компонента React, а зміни значення елемента викликають обновлення стану компонента. Це дозволяє реагувати на зміни значень,
        виконувати валідацію, встановлювати значення за замовчуванням і здійснювати інші дії контролю над елементами форми
    </p>
    <p>Контрольовані елементи форми в React дозволяють зберігати значення елементів
        форми у стані компонента та реагувати на зміни значень за допомогою обробників подій
    </p>
    <p>Такий підхід до роботи з формами надає багато переваг. Наприклад</p>
    <p>• Значення елементів форми зберігаються у централізованому стані компонента, що полегшує управління та синхронізацію
        значень.
        • Можна виконувати валідацію введених даних, перевіряти на належність певному формату і реагувати на помилки.
        • Значення елементів легко синхронізувати з іншими компонентами або використовувати для відправки на сервер.
        • Компонент повністю контролює значення елементів, що дозволяє здійснювати додаткову обробку перед відправкою
        форми, наприклад, валідацію або підготовку даних.
    </p>
    <p>Таким чином, контрольовані елементи форми в React дозволяють більшу гнучкість та контроль над взаємодією з формами,
        роблять їх легкими у використанні та дозволяють забезпечити надійну та попередньо валідовану обробку введених даних.
    </p>
    <h2>Чекбокси</h2>
    <p>У JSX-частині компонента ми маємо елемент <input> з типом checkbox.
        Атрибут checked пов'язаний зі станом checked, що забезпечує відображення
        правильного стану чекбоксу на основі значення стану. Також,
        використовується обробник onChange, який викликається при зміні стану
        чекбоксу. <br>
        Отже, коли користувач вибирає або знімає позначку чекбоксу, викликається
        обробник handleCheckboxChange, який оновлює стан checked. І навпаки,
        якщо стан checked змінюється, чекбокс автоматично оновлюється, щоб
        відображати актуальний стан.
    </p>
    <h2>Радіокнопки</h2>
    <p>У JSX-частині компонента ми маємо елементи <input> з типом radio. Кожен елемент має
        своє унікальне значення, яке встановлене за допомогою атрибута value. Наприклад, у
        прикладі ми маємо три радіокнопки зі значеннями "option1", "option2" і “option3". <br>
        Атрибут checked кожного <input> пов'язаний зі станом selectedOption. Це забезпечує
        правильне відображення вибраної радіокнопки на основі значення стану. Наприклад, якщо
        selectedOption має значення "option2", то радіокнопка з value="option2" буде
        відображена як вибрана.
    </p>
    <p>Обробник події onChange викликається при зміні стану радіокнопок. У нашому прикладі,
        він викликає функцію handleOptionChange, яка оновлює стан selectedOption залежно
        від значення вибраної радіокнопки (event.target.value). <br>
        Таким чином, коли користувач вибирає іншу радіокнопку, викликається обробник
        handleOptionChange, який оновлює стан selectedOption з відповідним значенням. В
        результаті, радіокнопки відображають актуальний стан вибору. <br>
        За допомогою цього підходу до роботи з радіокнопками, ви можете контролювати стан
        вибору, отримувати значення з вибраних радіокнопок і виконувати додаткову логіку на
        основі вибору користувача.
    </p>
    <h2>Селект</h2>
    <p>У прикладі ми використовуємо два стани selectedOption1 і selectedOption2
        для збереження вибраних значень у першому і другому тег select відповідно.
        Для кожного select ми використовуємо атрибут value, який пов'язаний з
        відповідним станом і визначає, яке значення має бути вибране у випадаючому списку.
        Обробник onChange викликається при зміні вибраного значення і оновлює стан
        selectedOption1 або selectedOption2 відповідно до зміненого значення.
        При надсиланні форми (submit), викликається функція handleSubmit. Ви можете
        використовувати значення selectedOption1 і selectedOption2 для виконання
        певних дій або для відправки на сервер. В даному прикладі, можна використовувати
        значення selectedOption1 і selectedOption2 для подальшої обробки, наприклад,
        для здійснення вибору опцій або для виконання певних дій на основі вибору
        користувача.
    </p>
    <p>Наступний приклад дозволяє гнучко налаштувати елементи option у select за
        допомогою мапування масиву об'єктів. Ви можете легко додавати, видаляти або
        змінювати елементи options, і елемент select автоматично оновлюватиметься
        згідно зі змінами.
        У цьому прикладі ми використовуємо масив options, який містить об'єкти зі
        значеннями та мітками для елементів option. За допомогою функції map, ми
        перебираємо цей масив та створюємо елемент option для кожного об'єкта у
        масиві. Кожен елемент option має унікальний ключ key (в нашому випадку
        використовується значення option.value) і встановлює значення та мітку з
        відповідного об'єкта option.
        При зміні вибраного значення, обробник handleOptionChange оновлює стан
        selectedOption з новим значенням. При надсиланні форми (submit), викликається
        функція handleSubmit, в якій ви можете використовувати значення
        selectedOption для подальшої обробки або відправки на сервер.
    </p>
</body>
</html>