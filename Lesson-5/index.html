<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-5</title>
</head>
<body>
    <h2>Життєвий цикл</h2>
    <p>Життєвий цикл React компонента визначає послідовність подій і методів, які відбуваються під час створення,
        оновлення та видалення компонента. Розглянемо детальніше кожен етап життєвого циклу React компонента.
    </p>
    <h3>Створення чи монтування (Mounting):</h3>
    <p>constructor: Цей метод викликається першим інстанціюванням компонента. Використовується для ініціалізації стану, прив'язки методів та
        обробників подій
    </p>
    <p>Врахуйте, що з введенням React Hooks у React 16.8 і далі, конструктор не є обов'язковим для використання в функціональних
        компонентах. Замість цього, ви можете використовувати хуки, такі як useState, для ініціалізації стану та інших значень.
    </p>
    <p>static getDerivedStateFromProps: Метод використовується для оновлення стану компонента на основі нових вхідних
        властивостей (props). Ось декілька прикладів використання getDerivedStateFromProps як методу життєвого циклу в React
        компонентах.
    </p>
    <p>Важливо пам'ятати, що getDerivedStateFromProps є статичним методом,
        тому він не має доступу до значення this та інших методів члена компонента.
        Його основне використання полягає у випадках, коли необхідно оновити стан
        компонента на основі нових вхідних властивостей без взаємодії зі станом
        компонента безпосередньо.
    </p>
    <p>render Метод використовується як частина життєвого циклу "Створення" (Mounting) для відображення
        компонента. Ось декілька прикладів використання render як методу життєвого циклу React компонента під час
        створення.
    </p>
    <p>Метод render викликається під час створення компонента і при кожному оновленні компонента. Його виклик відбувається
        автоматично React і повинен повернути дерево React-елементів для відображення. <br>
        Важливо зазначити, що метод render повинен бути чистою функцією, що означає, що він повинен завжди повертати одне й те ж
        значення для одних і тих самих вхідних даних. Він не повинен здійснювати прямих змін до стану компонента або взаємодіяти з DOM
        безпосередньо. Це дозволяє React ефективно оновлювати тільки необхідні частини DOM при змінах в стані компонента. <br>
        Після виклику методу render результат його виконання використовується React для оновлення DOM згідно з
        відповідними змінами у стані компонента або властивостях. React також може порівнювати результати попереднього та
        поточного виклику render для визначення, чи потрібно виконати оновлення DOM, зберігаючи при цьому ефективність. <br>
        Використання методу render дозволяє відобразити компонент та всі його дочірні компоненти. Через його виклик ми можемо контролювати, як
        саме компонент має бути відображений на екрані, використовуючи JSX-синтаксис та розміщуючи різні елементи та компоненти відповідно до
        потреб програми. <br>
        Виклик методу render є важливим етапом життєвого циклу React компонента, оскільки саме цей метод відповідає за
        відображення компонента та його структури на екрані.
    </p>
    <p>componentDidMount Метод використовується як частина життєвого циклу React компонента під час створення (mounting) для виконання
        дій після того, як компонент був вперше відображений на екрані. Ось декілька прикладів використання componentDidMount як методу
        життєвого циклу.
    </p>
    <p>Виклик методу componentDidMount забезпечує гарантію, що ініціалізація відбудеться після того, як компонент буде вперше
        відображений на екрані. Це дозволяє уникнути проблем з викликом некоректних методів або неповною ініціалізацією компонента. <br>
        Загалом, метод componentDidMount є потужним інструментом для виконання дій, які потрібно зробити
        один раз при створенні компонента та після його першого відображення на екрані.
    </p>
    <h2>Стадія оновлення (Update):</h2>
    <p>Оновлення може бути викликано зміною state самого компонента або props, що йому передаються. Під час оновлення необхідно
        перерендерити компонент, що призводить до виклику наступних методів.
    </p>
    <p>shouldComponentUpdate Метод використовується в життєвому циклі React компонента для визначення, чи потрібно
        оновлювати компонент та повторно рендерити його, коли змінюється його стан або властивості. Ось декілька прикладів
        використання shouldComponentUpdate як методу життєвого циклу.
    </p>
    <p>Використання методу shouldComponentUpdate дозволяє контролювати, коли компонент повинен бути оновлений та повторно
        рендеритися. Це особливо корисно, коли ми маємо великий компонент з багатьма вкладеними підкомпонентами, і не кожна зміна стану
        або властивостей потребує повторного рендерингу всього компонента. Замість цього, ми можемо використовувати
        shouldComponentUpdate, щоб визначити, які зміни потребують оновлення та які - ні, що сприяє покращенню продуктивності програми.
    </p>
    <p>Важливо пам'ятати, що метод shouldComponentUpdate є необов'язковим, і за замовчуванням повертає значення true, що означає,
        що компонент завжди оновлюється при зміні стану або властивостей. Його використання потребує обережності та правильного
        порівняння значень, щоб уникнути непередбачуваної поведінки компонента.
    </p>
    <p>Застосування getSnapshotBeforeUpdate корисно в ситуаціях, коли потрібно отримати попередній стан компонента перед змінами та виконати певні дії
        засновані на цьому знімку. Наприклад, це може бути корисно для анімацій, де потрібно зробити розрахунки на основі розташування або розміру
        компонента до оновлення.
    </p>
    <p>Важливо пам'ятати, що метод getSnapshotBeforeUpdate є необов'язковим і не завжди потрібний в життєвому циклі компонента. Він використовується
        в особливих випадках, коли потрібно отримати попередній стан або інформацію перед оновленням компонента. Також важливо дотримуватись деяких
        правил при використанні getSnapshotBeforeUpdate.
    </p>
    <p>Використання методу getSnapshotBeforeUpdate може бути корисним, коли вам потрібно отримати попередній стан компонента
        перед оновленням та виконати певні дії на основі цього стану. Наприклад, це може бути корисно для анімацій, синхронізації зовнішніх
        бібліотек або для взаємодії з DOM елементами.
    </p>
    <p>componentDidUpdate - це метод життєвого циклу в React компонентах, який викликається після оновлення компонента і оновлення
        DOM. Він надає можливість виконати певні дії, що пов'язані з оновленим станом компонента, зміненими властивостями або оновленим
        DOM після кожного оновлення.
    </p>
    <p>componentDidUpdate може бути використаний для виконання різних дій після оновлення компонента. Ось кілька прикладів: <br>
        Взаємодія з зовнішніми бібліотеками: Якщо у вас є зовнішня бібліотека або плагін, який потребує оновлення при зміні деяких властивостей або
        стану компонента, ви можете викликати відповідні методи або функції в componentDidUpdate. Наприклад, ви можете оновити карту, графік або
        анімацію на основі нових даних. <br>
        Запити до сервера: Якщо ви потребуєте виконати запит до сервера після зміни властивостей або стану, componentDidUpdate може бути
        використаний для ініціювання запиту. Зверніть увагу, що вам потрібно обережно використовувати componentDidUpdate, оскільки неправильне
        управління запитами може призвести до непередбачуваної поведінки та зацикленості. <br>
        Оновлення локального сховища: Якщо у вас є локальне сховище, таке як LocalStorage або Redux, ви можете оновити це сховище залежно від
        змін у компоненті. Наприклад, ви можете зберігати дані в локальному сховищі при зміні стану або властивостей, щоб зберігати проміжні дані або
        зберігати стан компонента між перезавантаженнями сторінки. <br>
        Взаємодія з DOM: componentDidUpdate також може бути використаний для взаємодії з DOM елементами після оновлення компонента.
        Наприклад, ви можете оновити значення введення або перемістити фокус на певний елемент після оновлення компонента. <br>
        Важливо пам'ятати, що componentDidUpdate викликається після рендерингу компонента та оновлення DOM.
    </p>
    <h2>Стадія розмонтування (Unmounting):</h2>
    <p>componentWillUnmount є методом життєвого циклу в React компонентах, який викликається перед видаленням компонента з DOM. Цей
        метод дозволяє виконати певні очищувальні дії, відписатися від підписок, зупинити таймери або виконати будь-які інші дії, необхідні для
        підготовки компонента до його знищення
    </p>
    <p>Ось кілька прикладів використання componentWillUnmount: <br>
        Відписка від подій або підписок: Якщо ваш компонент
        підписується на зовнішні події або отримує дані зі стрімів або
        WebSocket, componentWillUnmount може використовуватися для
        відписки від цих подій або підписок перед видаленням компонента.
        Наприклад, ви можете викликати removeEventListener або
        виконати метод unsubscribe для очищення підписки.
    </p>
    <p>Зупинка таймерів або інших асинхронних операцій: Якщо у вас є
        активні таймери, заплановані завдання або асинхронні операції, які
        повинні бути зупинені перед видаленням компонента,
        componentWillUnmount може бути використаний для їх припинення або
        очищення.
    </p>
    <p>Використання componentWillUnmount дає вам можливість коректно і гнучко керувати очищенням ресурсів, відпискою від подій та
        зупинкою асинхронних операцій під час знищення компонента. Це допомагає уникнути пам'яткових утечок та непередбачуваної поведінки у
        вашому додатку.
    </p>
    <h2>Обробка помилок рендера</h2>
    <p>componentDidCatch є методом життєвого циклу в React компонентах, який викликається при виникненні помилки в компоненті або його
        дочірніх компонентах. Він дозволяє компоненту обробити помилку і відобразити альтернативний вміст замість збоючого компонента, що
        допомагає уникнути зламаного UI та забезпечити гнучке управління помилками.
    </p>
    <p>React дуже любить класти всю програму за будь-якої помилки. Метод componentDidCatch спрацьовує при помилці в
        дочірньому компоненті та дозволяє батьківським компонентам відловлювати помилки у дітях, відображаючи запасний
        інтерфейс. В результаті, за помилки, інтерфейс не падає.
    </p>
    <p>ErrorBoundary можна використовувати як обгортку навколо будь-якого компонента,
        який потенційно може викликати помилки.
    </p>
    <p>В разі, якщо ComponentThatMightThrowError викличе помилку під час
        свого рендерингу або життєвого циклу, ErrorBoundary перехопить
        помилку, викличе componentDidCatch і відобразить альтернативний вміст
        замість збоючого компонента.
    </p>
    <p>Використання componentDidCatch та компонента ErrorBoundary дозволяє ефективно керувати помилками в React додатках. Ось
        кілька прикладів ситуацій, коли це може бути корисно.
    </p>
    <p>Загортання зовнішніх компонентів: Ви можете використовувати ErrorBoundary для
        загортання зовнішніх компонентів або сторонніх бібліотек, які не контролюються вами. Це
        дозволяє уникнути збоїв, спричинених помилками в цих компонентах, і замість цього
        відображати альтернативний вміст або повідомлення про помилку.
    </p>
    <p>Обробка непередбачуваних помилок: Іноді можуть виникати непередбачувані помилки в
        самому додатку, які можуть привести до зламу всього інтерфейсу. Використання
        ErrorBoundary навколо кореневого компонента додатка дозволяє перехоплювати ці помилки
        і відображати альтернативний вміст, забезпечуючи користувачеві зручне повідомлення про
        помилку.
    </p>
    <p>Повідомлення про помилки: Ви можете використовувати componentDidCatch
        для запису помилок і відправлення їх на сервер для подальшого аналізу або
        відстеження. Ви можете використати сторонні бібліотеки, такі як Sentry або
        Bugsnag, для цієї мети. Це дозволяє вам ефективно виявляти та вирішувати
        помилки, що виникають у вашому додатку.
    </p>
    <p>Важливо зазначити, що componentDidCatch працює тільки для помилок, які виникають у методах рендерингу або життєвого циклу дочірніх
        компонентів. Він не перехоплює помилки, які виникають під час обробки подій, асинхронних операцій або в конструкторі компонента. Тому, якщо
        помилка виникає у зовнішніх компонентах, в обробнику подій або в асинхронному коді, вона не буде перехоплена componentDidCatch.
    </p>
</html>