<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-7</title>
</head>
<body>
    <h2>Хуки для оптимізації</h2>
    <p>Хуки для оптимізації в React - це функціональні API, які дозволяють покращити продуктивність компонентів та ефективно
        використовувати ресурси. Принцип їх роботи полягає в тому, щоб уникнути зайвих рендерів, непотрібного обчислення та
        зберігання незмінних значень між рендерами <br>
        Ці хуки використовуються для оптимізації рендерингу компонентів і зменшення навантаження на процесор і пам'ять. Основні
        принципи роботи хуків для оптимізації включають:
    </p>
    <p>Кешування результатів: Хуки, такі як React.memo і useMemo, дозволяють кешувати результати попереднього рендерингу компонента
        або обчислення значень. При наступних рендерах ці значення повторно використовуються, якщо пропси або залежності не змінилися,
        що допомагає уникнути зайвих обчислень.
    </p>
    <p>Кешування функцій: Хук useCallback дозволяє кешувати функції та використовувати їх знову, якщо залежності не змінилися. Це
        корисно для передачі функцій у дочірні компоненти, оскільки вони не перерендерюються без потреби.
    </p>
    <p>Меморізація значень: Хук useMemo дозволяє кешувати та меморізувати значення, які залежать від вхідних пропсів або змінних. Він
        використовує пам'ять, щоб зберегти попередні значення та повертати їх без зайвих обчислень.
    </p>
    <h2>useMemo</h2>
    <p>Хук useMemo використовується для кешування обчислених значень та їх повторного використання між рендерингами
    компонента. Він дозволяє зберігати значення, щоб уникнути зайвих обчислень під час кожного рендерингу, якщо вхідні
    залежності не змінилися.
    </p>
    <p>Цей підхід особливо корисний, коли обчислення займають багато часу або ресурсів. Використання useMemo дозволяє ефективно
    оптимізувати продуктивність додатка, уникнути зайвих обчислень та зберегти ресурси процесора. <br>
    Примітка: Важливо пам'ятати, що useMemo повертає кешоване значення, а не змінює саме значення list. Якщо ви змінюєте
    list, але хочете, щоб useMemo використовував оновлене значення, ви повинні змінити залежності у масиві другого аргументу
    useMemo.
    </p>
    <p>постійне використання useMemo не завжди є необхідним або доцільним. Використовуйте useMemo тоді, коли вам
    дійсно потрібно оптимізувати продуктивність і уникнути зайвих обчислень.
    </p>
    <p>Оскільки useMemo використовує пам'ять для кешування значень, надмірне використання може призвести до зайвого збільшення
    використання пам'яті. Тому слід використовувати useMemo з розумом і лише тоді, коли є реальна потреба в оптимізації
    </p>
    <p>Ось кілька випадків, коли варто розглянути використання useMemo: <br>
    Обчислювально важкі операції: Якщо у вас є функція або обчислення, які займають багато часу або ресурсів, використання useMemo
    може допомогти уникнути повторних обчислень і покращити продуктивність. <br>
    Передача значень у вкладені компоненти: Якщо ви передаєте значення з одного компонента в інший через пропси, і ви знаєте, що
    значення не змінюється, використання useMemo може уникнути зайвих перерендерів вкладених компонентів. <br>
    Операції залежності в ефектах: Якщо ви використовуєте useEffect і маєте залежності, використання useMemo для кешування значень
    залежностей може допомогти уникнути зайвих запусків ефектів
    </p>
    <p>Загалом, використовуйте useMemo там, де ви дійсно помічаєте проблеми з продуктивністю і впевнені, що використання кешування
    допоможе вирішити ці проблеми. Якщо ваш додаток працює швидко і без проблем, можливо, немає потреби в постійному використанні
    useMemo
    </p>
    <h2>useCallback</h2>
    <p>Хук useCallback використовується для кешування функцій і повертає кешовану версію функції, яка змінюється лише тоді,
    коли змінюються залежності. Використання useCallback допомагає уникнути створення нових функцій при кожному
    рендерингу компонента і забезпечити стабільність посилань на функції.
    </p>
    <p>Коли ви передаєте функцію як залежність масиву в useEffect і
    хочете забезпечити, щоб ця функція не створювалась знову при
    кожному рендері компонента, ви можете скористатися хуком
    useCallback. useCallback дозволяє кешувати функцію і повертати її
    стабільну версію, яка не змінюється між рендерами компонента.
    </p>
    <p>Підсумок, коли доцільно використовувати useCallback: <br>
    Передача функцій у дочірні компоненти: Якщо ви передаєте функцію в пропсах у дочірні компоненти, і ви хочете, щоб ця функція не
    перерендерювалась без потреби, використання useCallback допоможе забезпечити стабільність посилань. <br>
    Мемоізація функцій в ефектах: Якщо ви використовуєте useEffect і маєте залежності, які включають функції, використання useCallback
    для мемоізації функцій допоможе уникнути зайвих запусків ефектів. <br>
    Оптимізація рендерингу компонентів: Якщо у вас є обробники подій або функції, які викликаються під час рендерингу компонента,
    використання useCallback допоможе уникнути зайвих перерендерів. Особливо, коли ці функції передаються у дочірні компоненти, важливо
    використовувати useCallback, щоб забезпечити, що функції не створюються знову при кожному рендерингу батьківського компонента. <br>
    Оптимізація операцій залежності в хуках: Якщо ви використовуєте інші хуки, які мають залежності, наприклад useEffect або useMemo, і ви
    хочете, щоб ці залежності були стабільними між рендерингами, useCallback може бути використаний для кешування функцій, що
    використовуються як залежності.
    </p>
    <p>Загалом, використовуйте useCallback, коли вам дійсно потрібна стабільність посилань на функції та уникнення непотрібних перерендерів.
    Однак, важливо розуміти, що використання useCallback не є автоматичним рішенням для всіх випадків. Використовуйте його там, де це
    доцільно з точки зору продуктивності та оптимізації, але не надлишково використовуйте його без необхідності.
    </p>
    <p>Надмірне використання useCallback може призвести до зайвого споживання пам'яті та непотрібного складності коду. Ось декілька
    негативних наслідків, які можуть виникнути при надлишковому використанні useCallback: <br>
    Зайве споживання пам'яті: Коли ви використовуєте useCallback, він кешує функції, що призводить до зберігання цих функцій у пам'яті. Якщо
    ви надмірно використовуєте useCallback, це може призвести до зайвого використання пам'яті, особливо якщо кешовані функції є складними або
    великими. <br>
    Потенційна затримка рендерингу: Використання useCallback призводить до порівняння залежностей, що може зайняти деякий час під час
    рендерингу компонента. Якщо у вас є багато useCallback в компоненті або якщо залежності досить складні, це може призвести до затримок у
    рендерингу компонента. <br>
    Збільшена складність коду: Надмірне використання useCallback може призвести до збільшення складності коду і зробити його важким для
    читання та розуміння. Кожен useCallback потребує огляду залежностей і визначення, коли це дійсно необхідно. Якщо ви використовуєте
    useCallback без розуміння, це може призвести до заплутаного та важкого для супроводу коду. <br>
    Витрати на обчислення: Хоча useCallback допомагає уникнути непотрібних перерендерів, використання його для всіх функцій може призвести
    до додаткових витрат на обчислення. Особливо, якщо ви маєте прості функції, які не створюються заново під час рендерингу, немає потреби
    використовувати useCallback для них, оскільки це може бути надмірною оптимізацією. <br>
    Використовуйте useCallback там, де це дійсно необхідно, коли вам потрібна стабільність посилань на функції та оптимізація рендерингу
    компонентів. Але не надлишково використовуйте його без необхідності, оскільки це може призвести до негативних наслідків, таких як зайве
    споживання пам'яті та збільшена складність коду. Завжди оцінюйте ситуацію та вагайте переваги та недоліки, перш ніж використовувати
    useCallback у своєму коді.
    </p>
    <h2>React.memo</h2>
</body>
</html>