<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-7</title>
</head>
<body>
    <h2>Хуки для оптимізації</h2>
    <p>Хуки для оптимізації в React - це функціональні API, які дозволяють покращити продуктивність компонентів та ефективно
        використовувати ресурси. Принцип їх роботи полягає в тому, щоб уникнути зайвих рендерів, непотрібного обчислення та
        зберігання незмінних значень між рендерами <br>
        Ці хуки використовуються для оптимізації рендерингу компонентів і зменшення навантаження на процесор і пам'ять. Основні
        принципи роботи хуків для оптимізації включають:
    </p>
    <p>Кешування результатів: Хуки, такі як React.memo і useMemo, дозволяють кешувати результати попереднього рендерингу компонента
        або обчислення значень. При наступних рендерах ці значення повторно використовуються, якщо пропси або залежності не змінилися,
        що допомагає уникнути зайвих обчислень.
    </p>
    <p>Кешування функцій: Хук useCallback дозволяє кешувати функції та використовувати їх знову, якщо залежності не змінилися. Це
        корисно для передачі функцій у дочірні компоненти, оскільки вони не перерендерюються без потреби.
    </p>
    <p>Меморізація значень: Хук useMemo дозволяє кешувати та меморізувати значення, які залежать від вхідних пропсів або змінних. Він
        використовує пам'ять, щоб зберегти попередні значення та повертати їх без зайвих обчислень.
    </p>
    <h2>useMemo</h2>
    <p>Хук useMemo використовується для кешування обчислених значень та їх повторного використання між рендерингами
    компонента. Він дозволяє зберігати значення, щоб уникнути зайвих обчислень під час кожного рендерингу, якщо вхідні
    залежності не змінилися.
    </p>
    <p>Цей підхід особливо корисний, коли обчислення займають багато часу або ресурсів. Використання useMemo дозволяє ефективно
    оптимізувати продуктивність додатка, уникнути зайвих обчислень та зберегти ресурси процесора. <br>
    Примітка: Важливо пам'ятати, що useMemo повертає кешоване значення, а не змінює саме значення list. Якщо ви змінюєте
    list, але хочете, щоб useMemo використовував оновлене значення, ви повинні змінити залежності у масиві другого аргументу
    useMemo.
    </p>
    <p>постійне використання useMemo не завжди є необхідним або доцільним. Використовуйте useMemo тоді, коли вам
    дійсно потрібно оптимізувати продуктивність і уникнути зайвих обчислень.
    </p>
    <p>Оскільки useMemo використовує пам'ять для кешування значень, надмірне використання може призвести до зайвого збільшення
    використання пам'яті. Тому слід використовувати useMemo з розумом і лише тоді, коли є реальна потреба в оптимізації
    </p>
    <p>Ось кілька випадків, коли варто розглянути використання useMemo: <br>
    Обчислювально важкі операції: Якщо у вас є функція або обчислення, які займають багато часу або ресурсів, використання useMemo
    може допомогти уникнути повторних обчислень і покращити продуктивність. <br>
    Передача значень у вкладені компоненти: Якщо ви передаєте значення з одного компонента в інший через пропси, і ви знаєте, що
    значення не змінюється, використання useMemo може уникнути зайвих перерендерів вкладених компонентів. <br>
    Операції залежності в ефектах: Якщо ви використовуєте useEffect і маєте залежності, використання useMemo для кешування значень
    залежностей може допомогти уникнути зайвих запусків ефектів
    </p>
    <p>Загалом, використовуйте useMemo там, де ви дійсно помічаєте проблеми з продуктивністю і впевнені, що використання кешування
    допоможе вирішити ці проблеми. Якщо ваш додаток працює швидко і без проблем, можливо, немає потреби в постійному використанні
    useMemo
    </p>
    <h2>useCallback</h2>
    <p>Хук useCallback використовується для кешування функцій і повертає кешовану версію функції, яка змінюється лише тоді,
    коли змінюються залежності. Використання useCallback допомагає уникнути створення нових функцій при кожному
    рендерингу компонента і забезпечити стабільність посилань на функції.
    </p>
    <p>Коли ви передаєте функцію як залежність масиву в useEffect і
    хочете забезпечити, щоб ця функція не створювалась знову при
    кожному рендері компонента, ви можете скористатися хуком
    useCallback. useCallback дозволяє кешувати функцію і повертати її
    стабільну версію, яка не змінюється між рендерами компонента.
    </p>
    <p>Підсумок, коли доцільно використовувати useCallback: <br>
    Передача функцій у дочірні компоненти: Якщо ви передаєте функцію в пропсах у дочірні компоненти, і ви хочете, щоб ця функція не
    перерендерювалась без потреби, використання useCallback допоможе забезпечити стабільність посилань. <br>
    Мемоізація функцій в ефектах: Якщо ви використовуєте useEffect і маєте залежності, які включають функції, використання useCallback
    для мемоізації функцій допоможе уникнути зайвих запусків ефектів. <br>
    Оптимізація рендерингу компонентів: Якщо у вас є обробники подій або функції, які викликаються під час рендерингу компонента,
    використання useCallback допоможе уникнути зайвих перерендерів. Особливо, коли ці функції передаються у дочірні компоненти, важливо
    використовувати useCallback, щоб забезпечити, що функції не створюються знову при кожному рендерингу батьківського компонента. <br>
    Оптимізація операцій залежності в хуках: Якщо ви використовуєте інші хуки, які мають залежності, наприклад useEffect або useMemo, і ви
    хочете, щоб ці залежності були стабільними між рендерингами, useCallback може бути використаний для кешування функцій, що
    використовуються як залежності.
    </p>
    <p>Загалом, використовуйте useCallback, коли вам дійсно потрібна стабільність посилань на функції та уникнення непотрібних перерендерів.
    Однак, важливо розуміти, що використання useCallback не є автоматичним рішенням для всіх випадків. Використовуйте його там, де це
    доцільно з точки зору продуктивності та оптимізації, але не надлишково використовуйте його без необхідності.
    </p>
    <p>Надмірне використання useCallback може призвести до зайвого споживання пам'яті та непотрібного складності коду. Ось декілька
    негативних наслідків, які можуть виникнути при надлишковому використанні useCallback: <br>
    Зайве споживання пам'яті: Коли ви використовуєте useCallback, він кешує функції, що призводить до зберігання цих функцій у пам'яті. Якщо
    ви надмірно використовуєте useCallback, це може призвести до зайвого використання пам'яті, особливо якщо кешовані функції є складними або
    великими. <br>
    Потенційна затримка рендерингу: Використання useCallback призводить до порівняння залежностей, що може зайняти деякий час під час
    рендерингу компонента. Якщо у вас є багато useCallback в компоненті або якщо залежності досить складні, це може призвести до затримок у
    рендерингу компонента. <br>
    Збільшена складність коду: Надмірне використання useCallback може призвести до збільшення складності коду і зробити його важким для
    читання та розуміння. Кожен useCallback потребує огляду залежностей і визначення, коли це дійсно необхідно. Якщо ви використовуєте
    useCallback без розуміння, це може призвести до заплутаного та важкого для супроводу коду. <br>
    Витрати на обчислення: Хоча useCallback допомагає уникнути непотрібних перерендерів, використання його для всіх функцій може призвести
    до додаткових витрат на обчислення. Особливо, якщо ви маєте прості функції, які не створюються заново під час рендерингу, немає потреби
    використовувати useCallback для них, оскільки це може бути надмірною оптимізацією. <br>
    Використовуйте useCallback там, де це дійсно необхідно, коли вам потрібна стабільність посилань на функції та оптимізація рендерингу
    компонентів. Але не надлишково використовуйте його без необхідності, оскільки це може призвести до негативних наслідків, таких як зайве
    споживання пам'яті та збільшена складність коду. Завжди оцінюйте ситуацію та вагайте переваги та недоліки, перш ніж використовувати
    useCallback у своєму коді.
    </p>
    <h2>React.memo</h2>
    <p>React.memo - це вбудований компонент в бібліотеці React, який дозволяє оптимізувати рендеринг компонентів шляхом кешування
        їх результатів. Використання React.memo дозволяє уникнути зайвих рендерів компонентів, якщо їх властивості не змінилися.
    </p>
    <p>React.memo працює на основі порівняння вхідних властивостей компонента (props). Якщо властивості не змінилися,
        React.memo повертає закешований результат попереднього рендеру компонента, і рендеринг пропускається. Це дозволяє
        ефективно оптимізувати роботу зайвих рендерів компонентів, зокрема у випадках, коли компоненти мають велику кількість
        вкладених компонентів або велику кількість властивостей.
    </p>
    <p>Якщо використовувати React.memo без вказівки на власну функцію порівняння властивостей, він використовує поверхневе порівняння props
        (shallowEqual). Проте, якщо ваш компонент приймає великі об'єкти або функції, можливо, знадобиться визначити власну функцію порівняння
        властивостей для React.memo. Ви можете передати другим аргументом до React.memo функцію порівняння, яка приймає два аргументи:
        попередній props (prevProps) і новий props (nextProps), і повертає true, якщо властивості рівні, і false - якщо властивості відрізняються.
    </p>
    <p>React.memo корисно використовувати в ситуаціях, коли компоненти мають дорогі обчислення або велику кількість вкладених компонентів, але їх
        рендеринг повинен відбуватися тільки при зміні певних властивостей <br>
        Важливо пам'ятати, що React.memo працює тільки для порівняння props і не оптимізує перерендеринг компонента при зміні стану (state) або
        контексту (context). Для оптимізації рендерингу на основі стану використовуйте React.useMemo або React.useCallback.
    </p>
    <h2>Кастомні хуки</h2>
    <p>Кастомні хуки - це функції, які використовуються для спільного використання логіки між компонентами у React. Вони дозволяють вам витягнути
        спільну функціональність з компонентів і перенести її в окремий хук, який можна повторно використовувати в будь-якому компоненті. <br>
        Створення кастомного хука - це простий процес. Кастомний хук - це просто функція, яка починається з префіксу "use" (наприклад, "useCustomHook").
        Внутрішній код хука може містити будь-яку логіку, стан, ефекти або інші хуки React.
    </p>
    <p>Ви можете створювати кастомні хуки для будь-яких потреб
        вашого проекту і витягувати спільну логіку з компонентів, щоб зробити код більш читабельним, перевикористовуваним та підтримуваним.
        Інші приклади кастомних хуків, які можна створити, включають:
    </p>
    <p>useValidation - хук для валідації форм або полів на основі правил валідації. <br>
        useMediaQuery - хук для відстежування змін розміру екрану або медіа-запитів. <br>
        useLocalStorageState - хук, який комбінує функціонал useState зі збереженням стану в локальному сховищі браузера. <br>
        useDebounce - хук для відкладеного виклику функції після зміни значення протягом певного періоду часу. <br>
        useTheme - хук для роботи з темами і стилями в програмі.
    </p>
    <p>Ці приклади лише невелика частина того, що можна зробити з кастомними хуками. Ви можете створювати свої власні кастомні хуки для будь-якої
        логіки, яка повторюється у вашому проекті, що допомагає зберігати код організованим, модульним і легким у використанні.
    </p>
    <h2>Кастомні хуки бібліотека “react-use”</h2>
    <p>Бібліотека "react-use" є набором корисних кастомних хуків для React, які допомагають спростити розробку і покращити продуктивність ваших додатків.
        Вона містить широкий спектр хуків для різних використань, включаючи роботу зі станом, ефектами, клавіатурою, мережею, анімаціями та багато іншого.
    </p>
</body>
</html>