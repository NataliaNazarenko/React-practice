<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-4</title>
</head>
<body>
    <h2>Рендер за умовою</h2>
    <p>Для рендеру розмітки за умовою використовуються оператори розгалужень та умов. Умови можна перевіряти перед поверненням розмітки або
        прямо в JSX.
        Якщо за умовою нічого не повинно бути відрендерено, можна повернути “null”, “undefined”, “false” - вони не рендеряться.
        Якщо умова буде істиною буде виконано тендер компоненту.
        Залежно від вашої потреби, ви можете змінити умову та замінити вміст рендерованих компонентів на власний.
    </p>
    <p>“if” за допомогою логічного оператора “&&”</p>
    <p>“if…else” за допомогою тернарного оператора</p>
    <p>За допомогою оператора “if”</p>
    <h2>Рендер колекцій</h2>
    <p>У React, рендер колекцій (наприклад, масивів або списків) можна здійснити за допомогою методу ”map()”.</p>
    <h2>Key</h2>
    <p>Ключ (key) у React використовується для ідентифікації унікальності елементів масиву або списку компонентів під час їх
        рендерингу. Кожен елемент масиву або списку повинен мати унікальний ключ, щоб React міг ефективно визначати зміни та
        оновлювати компоненти.
    </p>
    <p>Ось деякі основні причини використання ключа: <br>
        Ідентифікація елементів: Ключ допомагає React-у відслідковувати, які елементи змінились, були додані або видалені.
        Кожен ключ повинен бути унікальним у межах колекції елементів. <br>
        Підвищення ефективності: Ключі допомагають React-у оптимізувати процес оновлення компонентів. При оновленні
        колекції React порівнює ключі попередніх елементів з новими і визначає, які елементи потрібно оновити, які додати або
        видалити. Це дозволяє зменшити кількість операцій оновлення та зберегти ресурси. <br>
        Підтримка стану компонентів: Ключі допомагають зберігати стан компонентів при оновленні. Коли елемент масиву або
        списку має ключ, React може зберегти стан цього елементу навіть після оновлення колекції.
    </p>
    <p>Як правило, використовуються унікальні ідентифікатори або значення, які вже присутні в даних, як ключі для елементів.
        Зазвичай це числа або рядки, які унікально ідентифікують кожен елемент.
    </p>
    <p>Індекси масиву унікальні, проте вони не стабільні – при
        перетасовуванні колекції ключі змінюються. Дата і час – унікальні,
        але не стабільні, оскільки постійно збільшуються. Таким чином, під
        час кожного рендеру створюються нові ключі. Використання
        випадкового числа рівносильно тому, що ключі взагалі не
        використовуються, оскільки випадкові числа не є унікальними або
        стабільними.
    </p>
    <p>Безпосередньо після рендерингу списку з ключами, React може використовувати ці ключі для визначення змін в колекції. Якщо ключі змінюються між оновленReact розпізнає, які елементи були додані або видалені.
    </p>
    <p>React знає, який елемент видалений, оскільки він порівнює ключі попередньої колекції з новим списком елементів.
        Важливо пам'ятати, що ключі повинні бути унікальними лише в межах колекції. Якщо ви маєте дві незалежні колекції, то ключі
        можуть повторюватись між ними.
    </p>
    <p>Наприклад, у випадку, коли ми маємо два незалежних списки елементів у компоненті: <br>
        У цьому випадку, хоча ключі в обох списках збігаються, React розуміє, що це різні колекції, і
        вони не перетинаються між собою. <br>
        Отже, ключ (key) у React є важливим атрибутом, який допомагає визначити унікальність елементів у
        колекціях, підвищує ефективні.
    </p>
    <h2>Props</h2>
    <p>Props (властивості) в React - це спосіб передачі даних вниз по дереву компонентів в React. Props є незмінними та доступними для
        читання, і вони передаються в компоненти як атрибути. 
    </p>
    <p>При зміні Props як і при зміні State компонент буде перерендерено!</p>
    <p>Основні характеристики Props: <br>
        Передача даних: Props дозволяють передавати дані від батьківського компонента до дочірніх компонентів. Батьківський
        компонент встановлює значення Props, а дочірній компонент отримує ці значення та використовує їх для відображення. <br>
        Незмінність: Props є незмінними, тобто вони не можуть бути змінені дочірніми компонентами. Вони можуть бути тільки читані. Це
        забезпечує безпеку та передбачуваність в передачі даних між компонентами. <br>
        Використання в JSX: Props використовуються в JSX, щоб передавати значення атрибутів компонентів. Вони передаються як пари
        "ім'я-значення" і можуть містити будь-який тип даних, включаючи примітивні значення, об'єкти, функції або навіть компоненти. <br>
        Передача через дочірні компоненти: Props можна передавати через кілька рівнів дочірніх компонентів. Кожен наступний
        компонент може отримати Props від свого безпосереднього батька та передати їх своїм дочірнім компонентам. <br>
        Використання в компонентній логіці: Компоненти можуть використовувати Props для прийняття рішень та змінення свого
        внутрішнього стану. Значення Props можуть впливати на роботу компонента, управляти його відображенням та взаємодією з
        користувачем.
    </p>
    <p>Також ви можете передавати не примітивні типи даних як Props. </p>
    <p>Props drilling (також відомий як прокладання пропсів) відбувається, коли потрібно передати дані через багато проміжних компонентів від
        батька до дитини. Це відбувається шляхом передачі пропсів через кожен компонент у ланцюжку, навіть якщо деякі компоненти не
        потребують цих пропсів.
    </p>
    <p>Переваги: <br>
        Простота: Props drilling є простим і прямолінійним способом
        передачі даних між компонентами. <br>
        Передбачуваність: Ви чітко бачите, звідки походить кожен пропс і
        куди йде. <br>
        Гнучкість: Props drilling дозволяє зберігати дані на рівні вищих
        компонентів, використовувати їх в багатьох дочірніх компонентах
        або навіть модифікувати дані у проміжних компонентах.
    </p>
    <p>Недоліки:
        Зайва передача даних: Якщо вам потрібно передати дані через
        багато проміжних компонентів, це може спричинити зайву
        передачу даних в компонентах, які їх не використовують.
        Збільшена складність: Із зростанням кількості компонентів у
        ланцюжку може збільшуватися склад
    </p>
    <p>Таким чином, використання Props дозволяє нам передавати дані вниз по дереву компонентів і
        використовувати їх у відображенні та логіці компонентів. Це допомагає створювати повторно
        використовувані та динамічні компоненти, що реагують на зміни вхідних даних.
    </p>
</body>
</html>