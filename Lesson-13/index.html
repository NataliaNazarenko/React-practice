<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-13</title>
</head>
<body>
    <h2>Props drilling</h2>
    <p>Props drilling, також відомий як прокидання пропсів, відбувається, коли потрібно
        передати дані через кілька рівнів вкладеності компонентів в React. Це може
        стати проблемою, коли компонентам потрібен доступ до даних, які передаються
        через багато проміжних компонентів. Props drilling може призводити до зайвого
        коду і погіршувати читабельність.
    </p>
    <p>У прикладі значення data потрібно передати через ParentComponent та
        ChildComponent, щоб дістатися до GrandchildComponent, де воно фактично
        використовується. Це може призводити до багато непотрібного коду, особливо
        якщо є ще більше рівнів вкладеності.
    </p>
    <p>Props drilling може мати кілька негативних наслідків, особливо великих проектах зі складною структурою компонентів. Ось декілька проблем, з якими
        можна стикнутися при використанні прокидання пропсів:
    </p>
    <p>• Зайвий код: Кожен проміжний компонент, через який потрібно прокидати пропси, збільшує кількість коду. Це може призводити до зайвого шуму і
        зробити код менш зрозумілим та складним для обслуговування. <br>
        • Неспростовуваність: Якщо потрібно змінити пропс, який передається через кілька рівнів компонентів, це може бути незручно та час-consuming. Вам
        доведеться внести зміни у багатьох місцях, де прокидаються пропси, і відслідковувати, як вони впливають на різні компоненти. <br>
        • Зменшена читабельність: Якщо компоненти прокидаються через багато проміжних рівнів, код може стати важким для читання і розуміння. Важко
        встановити, які пропси використовуються в кожному компоненті і звідки вони походять. <br>
        • Потенційні помилки: Прокидання пропсів може призвести до потенційних помилок, особливо коли компоненти використовують однакові назви пропсів
        або коли пропси передаються неправильним чином через багато рівнів.
    </p>
    <p>Отже, хоча прокидання пропсів може бути використане в простих випадках, де немає багато вкладених компонентів, він може стати
        неефективним та незручним у великих проектах. В таких випадках використання контексту (Context API) або стейт-менеджерів, таких як Redux
        або MobX, може бути кращим рішенням для керування станом та передачі даних між компонентами.
    </p>
    <h2>Context API, useContext</h2>
    <p>useContext() - це хук в бібліотеці React, який дозволяє компонентам отримувати доступ до значень, які передаються через контекст. Використовуючи
        useContext(), компонент може отримати значення контексту безпосередньо, без необхідності передавати його через пропси від батьківських
        компонентів до дочірніх.
    </p>
    <p>Контекст в React дозволяє передавати дані через дерево компонентів, не зупиняючись на кожному рівні, де потрібно передати значення. Використовуючи
        useContext(), ми можемо звертатися до цих значень з будь-якого місця в дереві компонентів, яке має доступ до контексту.
    </p>
    <p>Приклад використання useContext():
        Спочатку створіть контекст з використанням createContext():
    </p>
    <p>Надайте значення контексту через компонент-постачальник
        (provider). Він огорнутий навколо компонентів, які мають отримувати
        доступ до цього контексту.
    </p>
    <p>Використайте useContext() у компоненті, щоб отримати доступ до
        значення контекст:
    </p>
    <p>У прикладі компонент ChildComponent отримує доступ до значення контексту MyContext ("Hello, World!") безпосередньо за допомогою
        useContext(). Не потрібно передавати значення контексту через пропси від App до ChildComponent.
    </p>
    <p>Щоб змінити контекст у дочірньому компоненті, вам знадобиться використовувати стан (state) разом з useContext(). Ось кроки, які потрібно
        виконати:
    </p>
    <p>Створіть контекст і компонент-постачальник так само, як описано в
        попередньому відповіді.
    </p>
    <p>В дочірньому компоненті використовуйте useContext(), щоб отримати значення
        контексту і функцію для його зміни:
    </p>
    <p>У прикладі дочірній компонент ChildComponent отримує значення
        контексту contextValue та функцію setContextValue для зміни значення
        контексту. При кліку на кнопку "Update Context" викликається функція
        updateContextValue, яка змінює значення контексту на "New Value" за
        допомогою setContextValue.
    </p>
    <p>Таким чином, ви можете оновлювати значення контексту у дочірньому компоненті
        та передавати його змінене значення іншим дочірнім компонентам, які також
        використовують цей контекст.
    </p>
    <p>useContext() можна використовувати для отримання доступу до різних типів даних, таких як об'єкти, функції, стан тощо. Використання контексту і
        useContext() дозволяє ефективно передавати дані вниз по дереву компонентів без необхідності передавати пропси через кожен проміжний
        компонент.
    </p>
    <h2>Стейт менеджери</h2>
    <p>У React існує кілька стейт-менеджерів, таких як Redux, MobX, Zustand і Context API з хуком useState. Кожен з цих стейт-менеджерів має свої
        особливості і призначення, і вибір між ними залежить від конкретних потреб вашого проекту.
    </p>
    <p>Ось деякі з причин, чому можна використовувати різні стейт-менеджери у React:</p>
    <p> - Redux: Redux є одним з найпопулярніших стейт-менеджерів у React. Він пропонує потужний засіб керування станом, заснований на концепції однієї
        центральної збереження (store), де всі дані вашого додатка зберігаються в одній структурі даних, що називається "store". Redux сприяє
        однозначності та простоті керування станом у великих додатках, де стан може бути складним та потребує багато дій та взаємодії між
        компонентами.
    </p>
    <p> - MobX: MobX - це стейт-менеджер, який пропонує більш просту та декларативну модель керування станом. Він базується на принципах
        спостереження (observables) та реакцій (reactions), що дозволяє автоматично відслідковувати та оновлювати стан за зміною залежностей. MobX
        підходить для швидкого розроблення прототипів або додатків зі складною логікою, які вимагають мінімального коду для керування станом.
    </p>
    <p> - Zustand: Zustand - це стейт-менеджер зі спрощеним API, який використовує хуки React для керування станом. Він надає спосіб зберігання та
        оновлення стану, який є простим у використанні та легким для розуміння. Zustand використовує контекст React та хуки, щоб забезпечити
        локальний стан компонентів та спільний стан між ними. Він може бути використаний для невеликих або середніх проектів, де простота та зручність
        є пріоритетом.
    </p>
    <p>Вибір стейт-менеджера залежить від розміру вашого проекту, складності стану та ваших особистих вподобань. У кожного з них є свої переваги та
        обмеження, і важливо розуміти, який стейт-менеджер найкраще підходить для вашого конкретного випадку.
    </p>
    <h2>Redux, Redux toolkit</h2>
    <p>Redux є популярною бібліотекою стану для JavaScript та React додатків. Вона пропонує потужні та прогнозовувані засоби керування станом вашого
        додатка, зокрема для багатокомпонентних та великих проектів. Redux Toolkit є додатковим шаром абстракції над Redux, який надає спрощену API та
        інструменти для зручного розроблення з використанням Redux.
    </p>
    <p>Ось кілька переваг Redux та Redux Toolkit:</p>
    <p>• Централізований стан: Redux пропонує підхід з централізованим збереженням стану вашого додатка. Весь стан зберігається в одній структурі даних,
        яка називається "store". Це спрощує управління та відстеження стану додатка, особливо при складній логіці та взаємодії між компонентами. <br>
        • Прогнозованість та розширюваність: Redux дозволяє прогнозувати, як стан зміниться у відповідь на дії користувача або події. Це робить код більш
        передбачуваним і полегшує відлагодження помилок. Крім того, Redux пропонує механізми розширення, такі як middleware, які дозволяють легко
        додавати додаткову функціональність до обробки дій та зміни стану. <br>
        • Розподілений доступ до стану: Завдяки Redux, будь-який компонент може отримати доступ до стану додатка, незалежно від його місця розташування у
        дереві компонентів. Це спрощує передачу даних та забезпечує єдину правду стану між компонентами. <br>
        • Redux Toolkit: Redux Toolkit надає спрощену API та набір інструментів для полегшення розробки з використанням Redux. Вона автоматично налаштовує
        багато основних властивостей Redux, таких як store configuration, immutable updates, серіалізацію даних та багато іншого. Вона також пропонує
        удосконалені інструменти, такі як createSlice та createAsyncThunk, для зменшення кількості необхідного коду та спрощення процесу розробки.
    </p>
    <p>Незважаючи на переваги, Redux також може мати деякі недоліки:</p>
    <p>• Більша складність для простих проектів: Redux може бути надмірним для невеликих або простих проектів, де стан не занадто складний або взаємодія
        з компонентами невелика. Використання Redux у таких випадках може призвести до зайвого коду та ускладнення розробки. <br>
        • Навчання та початковий поріг: Вивчення Redux може зайняти час, особливо для розробників, які ще не мали досвіду з управлінням станом.
        Вимагається розуміння концепцій, таких як actions, reducers та middleware. <br>
        • Потреба в багатофайловій структурі: Redux заохочує розділення логіки додатка на декілька файлів, що може призвести до більшої кількості файлів у
        вашому проекті. Для деяких розробників це може бути не зручно або ускладнити пошук та організацію коду.
    </p>
    <p>Враховуючи переваги та недоліки, використання Redux та Redux Toolkit рекомендується для великих та складних додатків, де централізоване керування
        станом є важливим. Для менших проектів або тих, де стан не є складним, можуть бути використані простіші альтернативи або вбудовані засоби React, такі як
        локальний стан за допомогою хуків.
    </p>
</body>
</html>