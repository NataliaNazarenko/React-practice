<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-16</title>
</head>
<body>
    <h2>Огляд базових компонентів в React Native</h2>
    <p>ActivityIndicator <br>
        Дефолтний лоадер
    </p>
    <p>Button <br>
        Базовий компонент кнопки, який має добре відображатися на будь-якій платформі.
        Підтримує мінімальний рівень налаштування.
    </p>
    <p>Image <br>
        Компонент React для відображення різних типів зображень, включно з
        мережевими зображеннями, статичними ресурсами, тимчасовими локальними
        зображеннями та зображеннями з локального диска, як-от фотопленка.
    </p>
    <p>У прикладі показано вибірку та відображення зображення з локального
        сховища, а також із мережі та навіть із даних, наданих у схемі uri «data:». <br>
        Зауважте, що для зображень мережі та даних вам потрібно буде вручну вказати
        розміри зображення!
    </p>
    <p>FlatList</p>
    <p>Ефективний інтерфейс для візуалізації простих плоских списків, що підтримує найбільш зручні функції: <br>
        Повністю кросплатформенний. <br>
        Додатковий горизонтальний режим. <br>
        Настроювані зворотні виклики видимості. <br>
        Підтримка заголовків. <br>
        Підтримка колонтитула. <br>
        Підтримка сепаратора. <br>
        Потягніть, щоб оновити. <br>
        Завантаження прокручування. <br>
        Підтримка ScrollToIndex. <br>
        Підтримка кількох стовпців.
    </p>
    <p>ImageBackground</p>
    <p>Поширеним запитом розробників, знайомих з Інтернетом, є фонове зображення.
        Щоб впоратися з цим випадком використання, ви можете використати
        компонент ImageBackground, який має ті самі властивості, що й Image, і
        додати до нього будь-які дочірні компоненти, які ви хочете накласти поверх
        нього. <br>
        Ви можете не використовувати <ImageBackground> у деяких випадках, оскільки
        реалізація проста. Зверніться до вихідного коду ImageBackground, щоб
        дізнатися більше, і за потреби створіть свій власний спеціальний компонент.
        Зауважте, що ви повинні вказати деякі атрибути стилю ширини та висоти.
    </p>
    <p>KeyboardAvoidingView</p>
    <p>Цей компонент автоматично регулюватиме свою висоту, положення або нижню
        частину на основі висоти клавіатури, щоб залишатися видимим, поки
        відображається віртуальна клавіатура.
    </p>
    <p>Modal</p>
    <p>Модальний компонент — це основний спосіб представити вміст поверх
        основного вікна
    </p>
    <p>RefreshControl</p>
    <p>Цей компонент використовується в ScrollView або ListView, щоб додати оновлення для оновлення
        функціональність. Коли ScrollView має значення scrollY: 0, проведення вниз запускає onRefresh
        подія.
    </p>
    <p>ScrollView</p>
    <p>Компонент, який обгортає платформу ScrollView, одночасно забезпечуючи
        інтеграцію з системою "відповідача" блокування дотиків. <br>
        Майте на увазі, що ScrollViews повинні мати обмежену висоту, щоб працювати,
        оскільки вони містять дочірні елементи необмеженої висоти в обмеженому
        контейнері (через взаємодію прокручування). Щоб обмежити висоту ScrollView,
        або встановіть висоту перегляду безпосередньо (не рекомендується), або
        переконайтеся, що всі батьківські перегляди мають обмежену висоту. Якщо
        забути передати {flex: 1} у стек представлень, це може призвести до помилок, які
        інспектор елементів швидко виправляє. <br>
        Поки що не підтримується блокуванням інших утримуваних відповідачів від того,
        щоб це подання прокрутки стало відповідачем.
    </p>
    <p>ScrollView проти FlatList – який з них використовувати?</p>
    <p>ScrollView рендерить усі дочірні компоненти react одночасно, але це має недолік
        продуктивності. <br>
        Уявіть, що у вас є дуже довгий список елементів, які ви хочете відобразити,
        можливо, вміст на кількох екранах. Створення JS-компонентів і власних
        представлень для всього відразу, багато з яких може навіть не відображатися,
        сприятиме повільному рендерингу та збільшенню використання пам’яті. <br>
        Ось тут і вступає в гру FlatList. FlatList відтворює елементи ліниво, коли вони
        збираються з’явитися, і видаляє елементи, які прокручуються далеко за межі
        екрана, щоб заощадити пам’ять і час обробки. <br>
        FlatList також зручний, якщо ви хочете відобразити роздільники між своїми
        елементами, кількома стовпцями, нескінченним завантаженням прокручування
        або будь-якою кількістю інших функцій, які він підтримує з коробки.
    </p>
    <p>Switch</p>
    <p>Це керований компонент, який потребує зворотного виклику onValueChange,
        який оновлює властивість значення, щоб компонент відображав дії користувача.
        Якщо властивість значення не оновлено, компонент продовжить відображати
        надану властивість значення замість очікуваного результату будь-яких дій
        користувача.
    </p>
    <p>Text</p>
    <p>Компонент React для відображення тексту.
        Текст підтримує вкладення, стиль і обробку дотиком.
    </p>
    <p>TextInput</p>
    <p>Базовий компонент для введення тексту в програму за допомогою клавіатури.
        Props надають можливість конфігурації для кількох функцій, таких як автоматичне
        виправлення, автоматичне використання великих літер, текст-заповнювач і різні
        типи клавіатури, як-от цифрова клавіатура.
    </p>
    <p>TouchableOpacity</p>
    <p>Обгортка для того, щоб зображення правильно реагували на дотики. При
        натисканні вниз непрозорість загорнутого вигляду зменшується, затемнюючи
        його.
        Непрозорість контролюється обгортанням дочірніх елементів у Animated.View,
        який додається до ієрархії перегляду. Майте на увазі, що це може вплинути на
        макет
    </p>
    <p>View</p>
    <p>Найфундаментальніший компонент для побудови інтерфейсу користувача, View
        — це контейнер, який підтримує макет із flexbox, стилем, деякою обробкою
        дотику та засобами керування доступністю. Переглядайте карти безпосередньо в
        еквіваленті нативного подання на будь-якій платформі, на якій працює React
        Native, незалежно від того, чи це UIView, div, android.view тощо.
        Представлення призначене для вкладення в інші представлення та може мати
        від 0 до багатьох дочірніх елементів будь-якого типу
    </p>
    <p>Pressable</p>
    <p>Pressable — це обгортка основного компонента, яка може виявляти різні етапи
        взаємодії преси з будь-яким із визначених дочірніх елементів
    </p>
    <p>Як це працює
        На елементі, обгорнутому Pressable:
    </p>
    <p>onPressIn викликається, коли натискання активовано. <br>
        onPressOut викликається, коли жест натискання дезактивовано. <br>
        Після натискання onPressIn відбудеться одне з двох:
    </p>
    <p>Людина прибере палець, активуючи onPressOut, а потім onPress.
        Якщо людина відпускає палець більше ніж на 500 мілісекунд, перш ніж прибрати
        його, спрацьовує onLongPress. (onPressOut все одно запускатиметься, коли вони
        приберуть палець.)
    </p>
    <h2>Обробка данних</h2>
    <p>Найпростіший випадок використання полягає в тому, щоб опустити TextInput і
        підписатися на події onChangeText для читання введеного користувачем. Є також
        інші події, такі як onSubmitEditing і onFocus, на які можна підписатися.
    </p>
    <p>TextInput за замовчуванням має рамку внизу свого перегляду. Ця межа має
        відступ, встановлений фоновим зображенням, наданим системою, і її неможливо
        змінити. Рішеннями, щоб уникнути цього, є або не встановлювати висоту явно, у
        цьому випадку система подбає про відображення межі в правильному
        положенні, або не відображати межу, встановивши для underlineColorAndroid
        значення прозоре.
    </p>
    <p>Зауважте, що на Android виконання виділення тексту під час введення може
        змінити параметр windowSoftInputMode активності програми на adjustResize. Це
        може спричинити проблеми з компонентами, які мають позицію: «абсолютний»,
        коли клавіатура активна. Щоб уникнути такої поведінки, укажіть
        windowSoftInputMode у AndroidManifest.xml (
        https://developer.android.com/guide/topics/manifest/activity-element.html ) або
        керуйте цим параметром програмно за допомогою власного коду
    </p>
    <p>Props <br>
        Ми можемо полегшити собі роботу з данними за допомогою пропсів:
    </p>
    <p>autoCapitalize- визначає які літери робити великими</p>
    <p>autoComplete - Визначає підказки щодо автозаповнення для системи, щоб вона
        могла забезпечити автозаповнення. В Android система завжди намагатиметься
        запропонувати автозаповнення за допомогою евристики для визначення типу
        вмісту.
    </p>
    <p>defaultValue - Надає початкове значення, яке зміниться, коли користувач почне
        вводити текст. Корисно для випадків використання, коли ви не хочете мати
        справу з прослуховуванням подій та оновленням властивості значення, щоб
        підтримувати контрольований стан у синхронізації.
    </p>
    <p>keyboardType - Визначає, яку клавіатуру відкрити, наприклад, цифрову</p>
    <p>maxLength - Обмежує максимальну кількість символів, які можна ввести.
        Використовуйте це замість реалізації логіки в JS, щоб уникнути мерехтіння.
    </p>
    <p>readOnly - Якщо true, текст не можна редагувати. Значення за замовчуванням -
        false.
    </p>
    <p>secureTextEntry is - Якщо значення true, введення тексту приховує введений
        текст, щоб конфіденційний текст, як-от паролі, залишався безпечним. Значення
        за замовчуванням - false. Не працює з multiline={true}.
    </p>
    <p>Також велика кількість обробників подій</p>
    <p>onBlur <br>
        onChange <br>
        onChangeText <br>
        onContentSizeChange <br>
        onEndEditing <br>
        onPressIn <br>
    </p>
    <h2>AsyncStorage</h2>
    <p>AsyncStorage - це аналлог localstorage у вебі
        Часто певні частини функцій, які підтримувались раніше з коробки react native
        тепер не підтримуванні і на офіційній сторіннці можна побачити рекомендацію в
        використовувати community packages.
        ось тут зібрані найпоширеніші https://reactnative.directory/?search=storage
    </p>
    <p>Можливо Вам доведеться зіткнутись зі старим кодом (і питанням "а чого воно не
        працює")
        Це виглядатиме так:
        import {AsyncStorage} from 'react-native';
    </p>
</body>
</html>